/*
01 분기
왜 분기가 필요할까
참/거짓 여부에 따라 코드를 나눠 실행할 수 있는 if, 변수의 값에 따라 실행할 수 있는 switch.

if
간단한 if의 사용
7_1.cpp

if가 항상 else를 데리고 다닐 필요는 없다.
7_2.cpp
else가 없으면 그냥 지나침.
실행코드가 한줄 밖에 없다면 중괄호를 적어주지 않아도 된다.

else if로 확장하기
7_3.cpp
else if 혼자 사용할 수 없고, if 뒤에서만 쓸수 있다.

if와 else는 한번밖에 올 수 없지만, else if는 사이에 얼마든지 존재할 수 있다.
7_4.cpp

else if분해해서 보기
7_5
if (age >= 20)
	cout << "성인입니다\n";
else if (male == true)
	cout << "성인이 아니면서 남자입니다\n";
7_6
if (age >= 20)
	cout << "성인입니다\n";
else{
	if (male == true)
		cout << "성인이 아니면서 남자입니다\n";
}
같은 기능을 하지만 7_5.cpp는 else가 나오지 않아 다른 코드이다.
완전히 같게 하려면 else if의 의미를 생각해 적어야 한다.
7_7
if (age >= 20)
	cout << "성인입니다\n";
if (!(age >= 20) && male == true)
	cout << "성인이 아니면서 남자입니다\n";
길어지기 때문에 그냥 else if를 쓰는게 낫다.

들여쓰기와 컴퓨터의 해석
Indentation은 글을 작성할 때 문단의 처음을 띄어서 쓰는 것을 의미.
들여쓰기는 순전히 개발자가 코드를 읽기 쉽게 하기 위한 용도. 실행과는 상관이 업다.
7_8
if (age >= 20)
	cout << "성인입니다\n";
else
{
if (male == true)
cout << "성인이 아니면서 남자입니다\n";
}

if와 관련된 실수들
1)if뒤에 세미콜론 찍지 않는다.
7_9
if(score == 100);
	cout << "축하합니다\n";
7_10
if(score == 100)
{
}
cout << "축하합니다\n";
if문에는 아무것도 없어 원하는 조건을 만들수없다.
2)=를 쓰지말고 ==를 쓰자.
7_11
if (score = 100)
	cout << "축하합니다\n";
이 경우 score에 100이라는 값을 대입하고 100을 반환하게 되어 true가 된다.
7_12
if (100 == score)
	cout << "축하합니다\n";
상수를 왼쪽에 적어줌으로써 =를 쓰는 일을 사전에 방지.

switch/case
간단한 switch/case의 사용
정수 타입의 입력을 받아서 그 값에 따라서 다수 개의 다른 코드 중 하나를 실행하게 해준다.
7_13.cpp
입력은 변수여야하고, case뒤에 오는 값은 반드시 상수여야합니다.
case의 끝은 세미콜론이 아닌 콜론으로 끝난다는 점에 주의.

break를 제거해도 오류가 나는 것은 아니지만 원하는 결과가 나오지는 않는다.
7_14.cpp
break가 없다면 흐름이 이동되지 않는다. 즉 계속 이어서 다음 문장을 실행한다.

모든 case에 해당하지 않는 경우
default라는 키워드가 존재한다.
7_15.cpp
default블럭은 가장 아래쪽에 위치하는 것이 일반적이며, 소스를 이해하기에도 좋다.

case 붙여서 사용하기
7_16.cpp

switch/case와 if의 비교
switch/case는 한 변수를 두고 그 변수가 가지는 값에 따라 서로 다른 일을 하고자 할 때 사용.
나머지는 if로 처리하면 된다.
7_17.cpp

switch/case와 변수의 정의
7_18.cpp
하지만 'B'라면 위의 초기화를 실행하지 않고 'B'를 실행하므로 문제 발생 주석처리해도 문제.
이런 문제를 해결하기 위해서는 중괄호로 감싸줄 수 있다.
7_19.cpp

삼항 연산자
유일하게 3개의 피연산자를 입력 받는 연산자. 한줄에 다 쓸수 있는 if, else.
7_20.cpp
a>b가 조건이 되고 참인 경우 a가 거짓인 경우 b가 실행되고 반환해서 c에 대입.
if로 바꿔보면
7_21
if (a > b)
	c = a;
else
	e = b;

goto
조건 분기와 무조건 분기
조건 분기는 조건을 검사하고 결과에 따라서 서로 다른 코드로 실행 흐름을 이동하는 명령들.
무조건 분기는 조건 없이 명령을 만나면 무조건 정해진 위치로 실행의 흐름이 이동하는 명령.

아주 간단한 goto의 사용
7_22.cpp
goto를 실행하기 위해서는 실행의 흐름을 이동시킬 곳을 표시할 방법이 필요하다. 레이블.
여러 개의 레이블을 만드는 것도 가능하다.

goto를 사용하지 말라
소스코드를 읽는 것도 힘들어지고, 관리하기도 힘들어지기 때문.
흐름을 이동시킬 필요가 있다면 반복 명령들을 사용하는 것이 좋다.
대부분은 분기, 반복 명령을 사용해서 대체할 수 있다.
하지만, 반복이 여러개 중첩해 있다면 완전히 빠져나오게 만드는것이 간단하지 않는데,
goto를 사용해서 한번에 모든 반복을 빠져나가게 하는 것이 오히려 유리.

02 반복
왜 반복을 사용해야 할까
비슷한 일을 여러 번 하는데 사용.

while
아주 간단한 while의 사용
7_23.cpp
입력한 조건이 true일 동안 while의 중괄호를 반복해서 실행하는 것.

조건의 다양한 활용
while의 조건 부분은 매번 반복을 시작하기 전에 검사한다. 만족해야 중괄호 실행가능.
7_24.cpp
조건부는 매번 실행되기 때문에 ++i도 매번 실행.

더간단하게 만들면
7_25.cpp
정수 값 0이 bool타입으로 해석되면 false가 된다는 점을 이용.
while(--i) == while(--i != 0)
한 문장만 들어 있다면, 중괄호 없어도 된다.

break
조건부를 true로 두어서 한없이 반복하게 만들 계획. 중괄호 안에 if를 두어 빠져나가게.
7_26.cpp
즉 중괄호를 빠져나가기 위한 키워드.

무한루프
Infinite Loops에 빠지는 경우가 있는데 CPU를 100%사용하는 경우가 된다.

for
아주 간단한 for의 사용
형식적이다. 변수의 초기화, 반복의 조건, 변수의 증가를 수행할 수 있는 영역을 지정해둠.
7_27.cpp
초기화 부분은 처음 딱 한번만 실행된다. 반복조건은 매번 반복을 시작하기 전에 검사한다.
증가치는 매번 반복이 끝난 후에 실행된다.
즉, for가 처음 시작하면 초기화 부분을 시행하고, 반복조건을 만족하면 한 번 실행하고,
다시 for로 돌아와 증가치 부분을 실행 후 반복조건을 검사를 반복.

변수의 초기화
for의 초기화 부분에서 반드시 변수를 정의할 필요는 없다.

for와 while의 비교
크게 다르지 않다. 문법적이냐 아니냐.
while이 요구하는 것은 '조건'하나다. 변수의 초기화나 증가치가 필요없으면 더 적합.

for의 배려를 무시하기
사용하고 싶지 않은 공간은 그냥 공백으로 내버려두면 된다.
증가시키지 않고 싶다면
7_28
for(int i = 1; i <= 10;){
	sum += i;
	++i; //i를 증가시킨다.
}
모두 사용하기 싫으면 while(true)와 같이 무한루프이기때문에 break가 필요.
7_29
for(;;){
	sum += i;
	++i;
	//조건을 비교한다.
	if(i > 10)
		break;
}
	

continue
이번 반복을 중단하고, 다음 번 반복으로 곧장 넘어가게 한다.
7_30.cpp
continue를 만나면 for의 처음으로 실행의 흐름을 이동한다.

for와 while과 관련한 실수
for나 while뒤에 실수로 세미콜론을 붙이면 무한 루프에 빠지게 된다.
7_30
while(i < 10);
7_31
while(i < 10){
}
i의 값이 변하지 않는 상태로 반복되기 때문에 조건은 항상 true.

중첩된 반복
for안에 for가 존재할 수 있고 다른 반복도 존재할 수 있다.
7_32.cpp

do while
아주 기본적인 do while의 사용
do while은 무조건 한 번 반복한 후에 조건을 검사한다.
7_33.cpp

반드시 한 번은 실행한 후에 조건을 검사해야 되는 경우에 유용하다.
do while은 끝에 반드시 세미콜론을 붙여주어야 한다.

이 경우는 보통 코드를 한 번 반복한 후에야 반복 조건을 검사할 수 있는 경우.
7_34
//사용자로부터 값을 받을 변수
int n;
do{
	//사용자로부터 값을 받는다.
	cin >> n;
} while (10 != n);
이것을 while이나 for를 이용해 구현하려면 더 적어야 한다.
7_35
//사용자로부터 값을 받을 변수
int n;
//사용자로부터 값을 받는다.
cin >> n;
while (10 != n){
	//사용자로부터 값을 받는다.
	cin >> n;
}
동일한 코드가 중복해서 존재한다는 것은 문제점을 내포하고 있는 것이다.
후에라도 이 코드를 수정할 일이 생긴다면 모두 수정을 해주어야 하기 때문.

*/