/*
01 포함
Inheritance & Containment는 이미 만들어진 클래스를 재사용하는 방법들.

왜 포함을 사용해야 할까
포함관계는 어떤 객체가 다른 객체를 포함하고 있는 관계를 의미한다.
사각형 객체는 점 객체를 포함하고 포함관계에 있다. 클래스도 마찬가지.
기존에 만들어진 클래스를 사용해서 새로운 클래스를 만든다면 많은 시간을 절약.
또한, 중복된 코드를 새롭게 만들지 않는다는 장점.

객체를 멤버로 갖는 클래스
사각형 클래스는 2개의 점 클래스로 이루어진다.
객체를 멤버로 사용하기.
22_1
Rect.h Rect.cpp 22_1.cpp
대부분은 접근자와 관련된 코드.
Point객체는 사각형의 왼쪽위의 점과 오른쪽아래의 점을 상징한다.
객체를 멤버 변수로 정의하면 포함 관계가 형성되는 것.
protected:
	Point _topLeft;
	Point _bottomRight;
};
주소
100
104
108 10 x ┐ _topLeft     ┐ rc1
112 20 y ┘              │
116 30 x ┐ _bottomRight │
120 40 y ┘              ┘
멤버 함수는 멀리떨어진 다른 메모리 영역에 있고, 그냥 구조체처럼 생각하면 된다.

Rect 클래스와 정보 은닉
약속된 것 - public으로 지정된 멤버 함수들의 원형. 그 함수들의 의미
약속되지 않은 것 - 두 개의 Point객체를 멤버로 갖음.
SetRect()멤버 함수의 '원형'과 그 멤버 함수의 '의미'가 바로 약속된 부분.
public으로 지정한 다른 멤버 함수들도 같은 식.
나중에 Point객체 2개 대신 다른것으로 바꿔도 객체 외부는 아무런 영향을 받지 않는다.
즉, main()함수안의 코드를 수정하지 않더라도 Rect클래스가 고칠 수 있다는 뜻.
결론적으로 Rect클래스는 자신을 다루는 방법만을 외부에 공개하고 구체적인
구현에 관한 정보는 숨기고 있기 때문에 정보 은닉이 잘 되있다.

생성자와 소멸자
지정하는 부분이 없으면 디폴트 생성자를 사용한다.
하지만 다른 생성자를 호출하게 만들 수도 있다.
22_2
Rect.h Rect.cpp 22_2.cpp
생성자의 초기화 리스트는 const 속성을 가지고 있는 멤버변수나 레퍼런스 멤버변수를
초기화할 때 사용했었는데, 멤버 변수인 객체의 생성자를 호출하는 데도 초기화 리스트.
멤버 변수인 객체의 이름을 적고 인자를 넘겨주면 알맞은 생성자가 호출.
Rect::Rect(int left, int top, int right, int bottom)
:_topLeft(left, top), _bottomRight(right, bottom)
_topLeft, _bottomRight 객체의 생성자를 호출한다.
생성자의 코드보다도 초기화 리스트가 먼저 실행된다는 것을 배웠다.
Point객체들의 생성자가 Rect클래스의 생성자보다 먼저 실행된다.
Point 객체들은 부품이고, Rect객체는 그 부품으로 이루어진 제품이다.
그렇기 때문에 포함된 객체들의 생성자를 먼저 호출하는 것이 타당하다.
같은 방식으로 소멸자의 호출 순서도 유추해볼 수 있다.
일단 제품을 분해한 다음에 부품들을 폐기하는 것이 옳은 순서.
그래서 Rect객체의 소멸자가 먼저 호출되고, Point객체들의 소멸자가 그 후에 호출.
Point::Point() -> Rect::Rect() -> Rect::~Rect() -> Point::~Point()
부품 먼저 완성  -> 전체가 완성   -> 전체 먼저 분해 -> 부품들이 분해

02 상속
문서 저장 클래스
기존의 클래스를 상속받아서 새로운 클래스를 만드는 법.
부모 클래스와 자식 클래스의 관계를 관리하는 기능.
자식 클래스가 부모 클래스의 모든 멤버를 물려받았다는 것만 기억.
문서저장 클래스를 공부한 후 상속해서 HTML저장 클래스를 만들어보자.

문서저장 클래스의 구현
DocWriter.h DocWriter.cpp 22_3.cpp
SetFileName()멤버 함수로 지정해준 이름대로 test.txt파일을 생성한다.
대부분이 생성자와 접근자 관련 코드며, 중요한 코드는 Write()멤버 함수.
DocWriter클래스는 SetContent()로 지정해준 문자열을 있는 그대로 파일에 써준다.

HTML문서 저장 클래스
HTMLWriter클래스는 DocWriter클래스와 거의 같은 일을 하지만 두개의 차이점이 있다.
1)웹브라우저에서 열어볼 수 있는 HTML형식으로 파일을 저장.
2)웹 형식의 문서인 만큼 텍스트의 폰트를 지정할 수 있는 기능도 추가.
22_4
HTMLWriter.h HTMLWriter.cpp 22_4.cpp
상속 받는 부분과 Write()함수의 변경을 제외하면 모두 생성자와 접근자.
상속받는 문법은 콜론을 찍어주고 public 키워드를 적고 클래스의 이름을 적으면 된다.
class HTMLWriter : public DocWriter{}
자식 클래스에는 부모 클래스에 없는 새로운 멤버를 추가할 수도 있고
부모 클래스에 이미 존재하는 멤버 함수를 새롭게 정의할 수도 있다.
자식 클래스의 객체는 부모 클래스가 가진 모든 멤버를 상속 받는다.
HTMLWriter 객체도 DocWriter 클래스의 모든 멤버를 소유하게 된다.
dw:_fileName, _content.
hw:_fileName, _content, _fontName, _fontSize, _fontColor

부모 객체와 자식 객체
DocWriter클래스는 부모클래스, HTMLWriter클래스는 자식클래스.
부모클래스의 객체 -> 부모 객체
자식클래스의 객체 -> 자식 객체

생성자와 소멸자
자식 객체를 생성할 때는 자식 클래스의 생성자 뿐만아니라 부모 클래스의 생성자도 호출.
자식 객체에는 부모로부터 상속받은 멤버들이 있는데 이 부분을 초기화하기 위해.
DocWrite클래스의 어떤 생성자를 호출할지 지정하는 방법.
22_5
HTMLWriter.h HTMLWriter.cpp 22_5.cpp
넘겨준 인자가 DocWriter의 클래스 생성자까지 올바르게 전달되었다.
초기화 리스트를 사용해서 부모 클래스의 생성자를 호출한다.
멤버인 객체를 초기화할 때는 객체의 이름을 사용했지만
부모 클래스를 초기화할 때는 클래스의 이름을 사용한다.
HTMLWriter::HTMLWriter(const string& fileName, const string& content)
:DocWriter(fileName, content){}
부모 클래스의 생성자를 자식 클래스의 생성자보다 먼저 실행한다는 사실을 발견할 수 있다.
초기화 리스트에서 부모 클래스의 생성자를 호출하기 때문이다.
부모 클래스 부분이 완전하게 생성한 후에 자식을 생성하는 것이 옳다.
그래서 부모 클래스의 생성자가 자식 클래스의 생성자보다 먼저 호출된다.
소멸자의 호출 순서는 그 반대가 된다.
자식 클래스에 해당하는 부분이 먼저 정리된 후에, 부모클래스에 해당하는 부분이 정리.
자식 객체의 생성 시:부모클래스의 생성자 -> 자식클래스의 생성자
자식 객체의 소멸 시:자식클래스의 소멸자 -> 부모클래스의 소멸자

클래스간의 형변환
여기서는 부모 클래스와 자식 클래스간의 형변환.

객체간의 형변환
객체간의 대입이라는 말이 더 어울린다.
같은 클래스타입의 대입이아닌 부모 객체와 자식 객체간의 대입을 알아보자.
부모 객체에서 자식 객체로의 대입
HTMLWriter hw; //자식 클래스 객체 생성
DocWriter dw; //부모 클래스 객체 생성
//부모 클래스의 객체를 자식 클래스의 객체로 대입
hw = dw; //실패
부모 클래스 객체를 자식 클래스 객체로 대입하는 것은 불가능하다.
객체의 대입이란 사실 모든 멤버 변수들의 1:1대입을 의미한다.
자식 객체에는 부모 객체에 없는 멤버가 있다.
즉, 이런 멤버는 자신을 초기화해줄 대상이 없는 상황.
그 반대의 경우는 가능.
자식 객체를 부모 객체로 대입하는 경우.
22_6.cpp
test.html파일을 생성했다는 점과 그 파일의 내용이 텍스트와 동일하다.
자식 객체의 멤버 변수들이 부모 객체의 멤버로 대입됐다는 점.
부모 객체와 자식 객체에 공통적으로 있는 멤버들이 1:1로 대입된다.
자식 객체에만 있는 멤버들은 아무런 영향을 미치지 않는다.

포인터간의 형변환, 레퍼런스간의 형변환
객체간의 대입보다 중요한 주제.
다형성과 가상함수를 이해하기 위해서.
자식 클래스의 포인터를 사용해서 부모 객체를 가리키는 경우.
//부모 객체 생성
DocWriter dw;
//자식 클래스의 포인터로 부모 객체를 가리킨다.
HTMLWriter* phw = &dw; //실패
이 경우는 암시적인 형변환을 허용하지 않는다.
컴퓨터가 안정성을 보장할 수 없기 때문.
예로 phw->fontColor처럼 사용하면 dw에는 멤버 변수가 없어 문제가 발생.
포인터가 아닌 레퍼런스를 사용한 경우에도 불가능하다.
//부모 객체 생성
DocWriter dw;
//자식 클래스의 포인터로 부모 객체를 가리킨다.
HTMLWriter& rhw = dw; //실패
하지만 반대의 경우는 허용된다.
부모 클래스의 포인터로 자식 객체를 가리키는 경우.
22_7.cpp
부모 클래스의 포인터로 자식 객체를 가리키는 경우에는 문제가 없다.
부모 클래스에 있는 모든 멤버는 자식 객체에도 있기 때문.
저장한 문서의 탑이 HTML포맷이 아닌 그냥 텍스트 포맷이다.
DocWriter::Write() 멤버 함수가 호출됐기 때문이다.
pDW의 타입이 DocWriter*기 때문에 DocWrite::Write()가 호출되야 한다고 주장할 수 있다.
pDW가 가리키는 객체는 실제로 HTMLWriter기 때문에 HTMLWriter::Write()가 호출되야
한다고 주장할 수 있다.
실제 객체가 무엇이던 간에 상관 없이 포인터의 타입을 기준으로 호출될 함수가 결정된다.
레퍼런스의 경우도 같다. 부모 클래스의 레퍼런스로 자식 객체를 참조하는 것이 허락.
레퍼런스 변수 타입이 DocWriter&이기 때문에 DocWriter::Write()멤버함수가 호출.
//HTMLWriter 객체 생성
HTMLWriter hw("test.html", "HTMLWriter content");
//DocWriter 클래스의 레퍼런스로 객체를 참조한다.
DocWriter& dw = hw;
//파일에 저장한다.
dw.Write(); //DocWriter::Write()가 호출된다.

자식 클래스의 포인터로 부모 객체를 가리키는 것이 왜 형변환일까?
자식 클래스의 포인터로 부모 객체를 가리키는 소스.
DocWriter dw;
HTMLWriter* phw = &dw; //실패
이것은 다음과 같다.
DocWriter dw;
DocWriter* pdw = &dw; //성공
HTMLWriter* phw = pdw; //실패
DocWriter*타입에서 HTMLWriter*타입으로의 형변환을 시도.
레퍼런스의 경우에도 동일
DocWriter dw;
DocWriter& rdw = dw; //성공
HTMLWriter& rhw = pdw; //실패

업캐스트와 다운캐스트
자식 클래스의 포인터가 부모 클래스의 포인터로 형변환하는 것을 업캐스트.
상속 계층도를 그렸을 때 아래에서 위로 변환하는 것이기 때문에.
반대로 부모 클래스의 포인터에서 자식 클래스의 포인터로 형변환하는 것을 다운캐스트.
허용되지도 않으면서 용어가 있는 이유는 경우에 따라 합법적.
HTMLWriter hw;
DocWriter* pdw = &hw; //업캐스트
HTMLWriter* phw = (HTMLWriter*)pdw; //다운캐스트
HTMLWriter객체의 주소를 업캐스트 했다가 다시 다운 캐스트하는 경우는 문제없다.
물론 컴퓨터는 pdw가 가리키고 있는것이 HTMLWriter객체라는 것을 모르기때문에 명시적으로.

접근제어
prtected와 private 키워드의 차이점

접근 제어 키워드 다시 보기
public:모든 곳으로부터의 접근을 허용한다.
protected:자식 클래스의 멤버 함수로부터의 접근만 허용한다.
private:자신의 멤버 함수 외에는 접근할 수 없다.
22_8.cpp
           자신의 멤버 함수에서 접근. 자식 클래스의 멤버 함수에서 접근. 외부에서 접근
private              o                            x                      x
protected            o                            o                      x
public               o                            o                      o
1)외부로부터 숨겨야 하는 멤버는 protected로 지정한다.
2)그 밖의 경우는 public으로 지정한다.
3)반드시 자식 클래스에 숨기고 싶다면 private로 지정한다.
자식 클래스에게까지 멤버를 숨겨야하는 경우는 흔치않다. 왠만하면 protected로.

포함과 접근 권한
포함의 관계를 가진 클래스들은 접근 권한에 있어서는 아무런 관련이 없는 클래스이다.
포함 관계를 가진 두 클래스는 여전히 상대방 클래스의 public멤버만 접근가능.

다중 상속
Multiple Inheritance는 두 개 이상의 부모 클래스를 동시에 상속하는 경우.

왜 다중 상속을 사용해야 할까
학부생이면서 동시에 기숙사생인 학생의 정보는 다중상속을 쓸수있다.

다중 상속의 사용
학부생 클래스, 기숙사생 클래스, 다중상속한 클래스.
22_9.cpp
std는 UnderGradStudent와 DormStudent클래스에서 받은 멤버들 모두 사용가능.

충돌 회피하기
부모 클래스에 동이한 이름의 멤버가 있는 경우는 어떻게 될까?
22_10.cpp
UnderGradStudent::Warn()과 DormStudent::Warn()중 어떤함수를 호출할지몰라 에러.
이런경우에는 구체적으로 밝혀줄 필요가 있다.
std.UnderGradStudent::Warn();

상속에서 가장 중요한 것은 자식 클래스가 부모 클래스의 모든 멤버를 상속받는다는 점.

포함과 상속을 구분해서 사용하기
둘 다 기존에 만들어진 클래스를 재사용한다는 공통점.
1)포함은 Has-a 관계다. A가 B를 가지고 있다면(Has) 포함을 사용하라.
2)상속은 Is-a 관계다. A가 B라면(Is) 상속을 사용하라.
Has-a 관계는 자동차와 타이어 관계.
자동차는 타이어를 가지고 있지만 타이어는 아니다.
Is-a 관계는 사과와 과일이다.
사과는 과일이다 하지만 사과과 과일을 가지고 있는 것은 아니다.
사각형은 점을 가지고 있을 뿐이므로 포함.
HTML저장클래스는 문서 저장 클래스의 한 종류다.
그러므로 상속 받게 하는 것이 옳다.



*/