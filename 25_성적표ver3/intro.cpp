/*
01 성적표 Ver 2.4 - 성적표 Ver 2.3의 버그 수정

성적표 Ver 2.3에 존재하는 버그 이해하기
프로그램이 종료하면서 메모리 릭이 발생한다.
이유는 링크드 리스트에 담긴 Student 변수들이 올바르게 해제되지 않기 때문이다.
링크드 리스트에 담긴 Student변수들은 동적으로 할당한 변수였다.
Student구조체에 소멸자를 만들어서 이 소멸자가 제대로 호출되는지 확인해보자.
디폴트 접근 권한이 public이라는 점을 제외하고 구조체는 클래스와 다를게 없다.
25_1
students.cpp
Student 변수의 소멸자가 호출됐다면 문자열이 두 번 출력됐어야 했지만 안나왔다.
Student클래스의 소멸자가 호출되지 않았음을 의미한다.
소멸자에서는 멤버들의 소멸자를 호출해주는 일을 한다.
name멤버 변수는 string클래스 타입이기 때문에 소멸자가 호출되지 않으면
문자열을 보관하는 데 사용했던 동적인 메모리를 해제할 기회를 잃어버린다.
25_2
list.cpp
delete current->data;에서 Student 구조체 변수를 해제해야 한다.
delete연산자의 하는 일은 두가지인데 객체에 알맞은 소멸자를 호출하는 것이고 
객체가 차지하는 메모리공간을 해제하는 것이다.
current->data는 void*타입이어서 delete연산자는 current->data가 가리키는 곳에
Student변수가 있다는 사실을 알 수 없다.
그래서 그냥 단순한 메모리블록이라고 생각하고 메모리 공간만 해제하는 것.
그러므로 delete연산자에게 current->data가 Student구조체를 가리킨다는 것을 알려야.
포인터가 Student*타입이므로 delete연산자는 Student구조체의 소멸자를 호출한다.
delete (Student*)current->data;
Student구조체의 소멸자가 올바르게 호출된다.
하지만 링크드 리스트의 범용성을 잃어버린다.
링크드 리스트가 Student구조체 변수 외에 다른 타입의 데이터를 보관하는 것이 불가능.
범용성을 그대로 유지하면서 소멸자를 올바르게 호출할 방법을 찾아보자.

소멸자를 만들지 않은 경우에는 어떻게 되나요?
Student구조체의 소멸자를 만들지 않은 경우에도 상황은 동일.
컴퓨터가 몰래 소멸자를 만들기 때문. 이 소멸자 역시 멤버 변수들의 소멸자를 호출하는 일.

성적표 Ver2.3의 버그 해결하기
링크드 리스트는 노드에 포함된 데이터의 타입을 알아서는 안된다. 범용성을 잃지 않기 위해.
동시에 노드에 포함된 데이터는 자신의 타입으로 형변환되고 해제되어야 한다. 소멸자호출.
데이터를 해제하는 작업은 데이터의 타입을 아는 쪽에서 하는 것이 타당하다.
노드의 데이터를 제거하는 소스코드는 링크드 리스트를 사용하는 쪽에서 제공하고,
링크드 리스트는 이 소스 코드를 사용해서 노드의 데이터를 제거하면 된다.
이런 일에는 함수의 포인터를 사용하는 것이 적격이다.
1)노드의 데이터 제거용 함수를 준비한다.
void DeleteData(void* data) {
	delete (Student*)data;
}
2)이 함수의 주소를 링크드 리스트에 알려준다.
&DeleteData
3)넘겨온 함수의 주소를 함수 포인터에 보관한다.
typedef void (*FN_DELETE)(void*);
FN_DELETE fnDel;
fnDel = &DeleteData;
4)노드의 데이터를 해제하고 싶을 때 보관된 함수 포인터를 사용해 함수를 호출.
(*fnDel)(node->data);
링크드 리스트에서 노드의 데이터를 제거하고 싶을 때 호출할 함수를 제공하는 것이 핵심.
링크드 리스트의 사용자가 제공한 함수를 사용하기 때문에 데이터가 올바르게 해제되는것을
보장 받을 수 있고, 링크드 리스트가 범용성을 잃지 않게 만드는데도 성공했다.
25_3
students.cpp
CreateList()함수에서 전달 받은 함수의 주소를 어떻게 처리하는지.
25_4
list.h list.cpp
보관한 함수의 주소를 사용해 노드의 데이터를 제거
25_5
list.cpp
함수의 포인터를 사용한 성적표 Ver2.4의 구조가 최선의 해결책은 아니다.
이 구조는 복잡하고 난해한 편.
링크드 리스트를 사용하려는 곳마다 DeleteData()함수를 만들어 넘겨야하는 단점.
성적표 Ver2.3의 상태를 보존하면서 최소한의 노력으로 버그를 해결하는 방법이었고,
실제로도 자주 사용하는 방법으로 함수 포인터의 적절한 사용법.

그렇다면 최선의 해결책은?
C++에서 링크드 리스트와 같은 자료구조를 만들 때는 일반적으로 탬플릿(Template)을 사용.

02 성적표 Ver 3.0 ~ 3.2 - 단계적인 클래스화
Ver3.0은 list.h와 list.cpp를 수정해 List와 Node구조체를 각각클래스로 만든다.
Ver3.1은 students.h와 students.cpp를 수정해 Students클래스를 만든다.
Ver3.2은 students.cpp에서 정의한 Student구조체를 클래스로만들고 파일도 새로.
링크드 리스트를 사용하는 코드들이 새로운 클래스를 사용하게 수정하는 작업도 병행.
일단 점진적인 개발이 몸에 익숙해지면 실수도 적어지고 개발 속도도 향상된다.
25_6
list.h
Node와 List가 클래스로 바뀌었다.
Node클래스가 List클래스를 친구로 설정해 외부말고 List에서만 접근 할 수 있게 했다.
즉, 링크드 리스트의 사용자가 실수로 Node객체의 값을 바꿔서 문제가 발생하는 것을 방지.
25_7
students.h stdents.cpp
학생정보를 입력 받거나 출력하는 코드가 Student클래스로 이동됐다.
만약 AddStudent()에서 직접 학생의 정보를 콘솔 창으로부터 입력 받아서
Student객체에 대입해도 잘 동작하지만 응집력이 떨어지는 결과를 낳는다.
Student클래스와 관련된 코드는 Student클래스 안에 모여 있는 것이 좋다.
클래스를 만들 때는 자신의 일을 스스로 하게 만드는 것이 좋다.
25_8
student.h student.cpp

Ver3.2의 소스 코드를 보면서 주의할 점
현실에서의 프로젝트는 제일 처음 만들때부터 클래스를 사용한다.
구조체에서 클래스로 바꾸는 것보다 클래스들의 모습 그 자체를 이해하려고 노력.

03 성적표 Ver 3.3 - 새로운 학생 클래스
새로운 종류의 학생 정보를 입력 받고 처리할 수 있게 기능을 추가.
국어, 영어, 수학에 더해서 고급 영어 과목을 듣는 학생.
다형성을 적용하는 방법을 가르쳐 주기 위한 만든 상황.
추가해야할 기능
1)고급 학생의 정보를 입력 받는 기능
2)고급 학생의 개인 평균을 계산하는 기능
3)성적표 출력 시 고급 학생의 정보를 출력하는 기능
가장 좋은 방법은 상속과 다형성을 사용하는 것.
Student클래스를 상속 받아 고급 영어와 관련된 기능을 추가해주면 된다.
EngStudent는 Student를 상속 받고, 주요 멤버 함수를 오버라이드 한다.
주요 멤버 함수와 소멸자를 가상함수로 만든다. 다형성을 사용하기 위해.
EngStudent클래스의 멤버 변수는 hi_eng하나지만, Student의 모든 멤버 변수들도 소유.
25_9
student.h student.cpp
고급학생의 정보를 입력 받기 위한 메뉴 항목을 추가.
그 메뉴를 선택한 경우에 MENU_ADD_STUDENT_END를 반환.
25_10
main.cpp
AddStudent()함수에 bool타입의 인자를 두어 구분하고 있다.
25_11
students.cpp
다형성을 사용하기 때문에 알맞은 객체를 생성한 후 동일한 코드가 사용됨.
성적표를 출력하는 부분의 코드
25_12
students.cpp
다형성을 사용해 Student::Show()혹은 EngStudent::Show()가 호출됨.
상속과 다형성이 프로그램을 유지 보수 하는데 많은 도움이 된다는 걸 알 수 있다.

04 성적표 Ver 3.4 ~ 3.5 - 다양한 방식의 성적표 출력
텍스트파일과 HTML파일로 성적표를 출력하는 기능을 추가.
ShowAll()함수와 비슷하게 ShowAllText()와 ShowAllHTML()
세 함수가 중복되는 코드를 포함하기 때문에 유지보수가 쉽지 않다.
ShowAll() '출력할 학생들의 정보를 가져오는 일'과 'cout 객체에 그 정보를 보내는 일'
출력할 학생들의 정보를 가져오는 일은 세 함수 모두 중복된다.
ShowAll()은 정보를 cout객체에 보내는 일
ShowAllText()은 정보를 텍스트 파일에 써넣는 일
ShowAllHTML()은 정보를 HTML형식으로 HTML파일에 써넣는 일
중복되면 변경할 일이 생길 때 모든함수에서 변경 작업이 이루어져야 한다.
이런 문제를 피하기 위해 ShowAll()함수에서 다형성을 이용하는 방법.
ShowAll()함수에서는 '학생들의 정보를 가져오는 일'만하게 만든다.
그리고 'cout객체에 정보를 보내는 일', '텍스트 파일에 정보를 보내는 일',
'HTML파일에 정보를 보내는 일'을 담당하는 3개의 클래스를 만든다.
그러면 ShowAll()함수에서는 목적에 맞는 클래스를 골라서 사용하면 된다.
다형성을 사용하기 위해서는 세 클래스의 부모 클래스가 필요하다.
ShowAll()함수는 이 부모 클래스의 멤버 함수들을 호출함으로써 필요한 작업을 수행.
BaseOutput이 부모클래스, ConsoleOutput, TextOutput, HTMLOutput이 출력하는 역할.
BaseOutput클래스에는 나머지 세 클래스가 오버라이드해서 구현할 순수 가상 함수들이 존재.
추상 클래스에 순수 가상 함수를 만들 때는 자식 클래스들 모두가 사용할 수 있게 만들어야.
25_13
BaseOutput.h
25_14
students.h students.cpp
ShowAll()함수는 이제 '출력할 학생들의 정보를 가져오는 일'만 한다.
그리고 이 정보를 출력 객체에게 넘겨준다.
출력 객체는 이 정보를 받아서 자신의 방식대로 출력할 것이다.
다형성을 사용하기 때문에 코드들은 출력 객체의 실제 타입을 알지 못한다.
std->Show(*out);
역시 다형성을 사용함으로 Student::Show()혹은 EngStudent::Show()가 된다.
25_15
student.cpp student.h
Show()함수 역시 다형성을 사용해서 출력 객체를 사용하고 있다.

왜 소멸자를 순수 가상 함수로 만들지 않았을까?
순수 가상 함수로 만들던지 가상 함수로 만들던지 별 상관이 없다.
일반적인 순수 가상 함수와는 달리 소멸자를 순수 가상함수로 만든경우,
소멸자의 구현을 제공해야 한다.
자식 클래스의 소멸자에 의해서 호출되어야 하기 때문에.

stringstream 클래스로 문자열 만들기
cin이나 cout객체처럼 사용할 수 있다는 특징.
cout << "제 아이큐는 " << 30 << "입니다"; //화면에 출력한다.
stringstream ss;
ss << "제 아이큐는 " << 30 << "입니다"; //ss 객체 내부에 있는 문자열에 출력한다.
cout 객체는 콘솔 화면으로 값을 출력하지만, 
ss객체는 자기 내부에 있는 문자열에 값을 출력.
ss객체 내부에 있는 문자열이 "제 아이큐는 30입니다"와 같은 값을 갖게 된다.
ss 객체 내부에 있는 문자열을 얻고 싶다면
string s;
s = ss.str();
객체 s도 "제 아이큐는 30입니다"라는 값을 갖게 된다.
stringstream클래스를 사용하기 위해서는 <sstream> 헤더파일을 포함.

stringstream을 사용해서 문자열 분리하기
cout객체처럼 사용할 수도 있지만 cin객체처럼 사용할 수도 있다.
string name;
int age;
cin >> name >> age; //콘솔 창으로부터 입력 받는다.
stringstream ss;
ss << "나는 30";
ss >> name >> age; //ss객체 내의 문자열로부터 입력 받는다.
ss객체는 자신의 내부에 있는 문자열로부터 입력을 받는다.
ss객체 내부의 문자열은 "나는 30"이라는 값을 갖게 됐고 그 이후 실행하면
name변수는 '나는', age는 '30'을 값으로 갖는다.

ConsoleOutput 클래스 구현하기
1)BaseOutput클래스 상속받기
2)순수 가상 함수들 오버라이드해서 구현하기
순수가상함수들을 구현할 때는 인자로 넘어온 정보를 콘솔 창에 출력하면 된다.
25_16
ConsoleOutput.cpp
'정보를 cout객체로 출력하는 일'은 이제 ConsoleOutput클래스가 맡게 됨.

HTMLOutput 클래스 구현하기
BaseOutput 클래스를 상속 받아서 순수 가상 함수들을 구현하면 된다.
HTMLOutput클래스는 인자로 넘어온 정보를 HTML파일로 출력할 것이다.
25_17
HTMLOutput.h
파일을 다루는 것이므로 ofstream객체를 멤버 변수로 만들었다.
생성자에서 파일을 열어두고, 나머지 함수들에서는 정보를 HTML형식으로 파일에 출력.

TextOutput 클래스 구현하기
기존 방법으로 구현해도 상관은 없지만 ConsoleOutput 클래스를 상속받아 해본다.
콘솔 창에 값을 출력할 때 사용하는 cout객체는 ostream클래스 타입이다.
그리고 파일에 값을 출력할 때는 ofstream클래스를 사용한다.
이 두 클래스는 부모 자식 관계에 있다.
ostream가 ofstream의 부모 클래스가되고 다형성을 사용해서 두 클래스를 다룰 수 있다.
cout객체에 값을 출력하는 코드를 그대로 사용해 ofstream객체에 값을 출력하게 한다.
25_18
ostream& GetTarget() {
	return cout;
}
void main() {
	GetTarget() << "Hello, World\n";
}
GetTarget()함수가 cout객체를 반환하기 때문에 "Hello, World"를 콘솔화면으로 출력.
25_19
//ofstream객체를 정의하고 test.txt 파일을 연다
ofstream fout("test.txt");
ostream& GetTarget() {
	return fout;
}
void main() {
	GetTarget() << "Hello, World\n";
}
GetTarget()함수를 보면 ofstream클래스 객체인 fout을 반환한다.
ofstream클래스는 ostream클래스의 자식 클래스기 때문에 문법적으로 문제가 없다.
GetTarget()함수는 fout을 반환하므로 "Hello, World\n"를 test.txt파일로 출력.
이런 방법으로 TextOutput클래스를 간단하게 만들어보자.
이전에는 cout객체를 직접 사용했지만 StdOut()이라는 멤버 함수에서 반환한 ostream&사용.
25_20
ConsoleOutput.cpp
cout객체를 직접사용하는 대신에 StdOut()함수를 사용한다.
ConsoleOutput클래스는 여전히 콘솔 창에 성적표를 출력하는 것이다.
다만 TextOutput클래스를 만드는 데 도움이 되게 내부 구조를 개선한 것.
ConsoleOutput클래스를 상속받아서 StdOut()멤버 함수만 오버라이드한 후에
cout객체가 아닌 ofstream클래스 객체를 반환한다.
25_21
TextOutput.h TextOutput.cpp
out포인터가 TextOutput객체를 가리키고 있다고 해보자.
TextOutput::BeginTable()함수는 존재하지 않으므로 ConsoleOutput의 함수가 호출.
StdOut()함수로부터 반환한 객체에 문자열을 출력한다.
StdOut()은 가상함수기 때문에 ConsoleOutput이 아닌 TextOutput::StdOut()이 호출됨.
실제 객체의 타입은 TextOutput이기 때문이다.
StdOut()을 호출한 부분은 사실 this->StdOut()을 줄여놓은 것.
this포인터는 ConsoleOutput*타입이지만 가리키는 실제적인 타입은 TextOutput이다.
StdOut()에 의해서 반환되는 객체는 ofstream클래스 타입의 객체가 되고 문자열은
텍스트 파일에 출력된다.
지금까진 클래스의 외부에서 호출했지만 객체 스스로 자신의 멤버인 가상함수를 호출했다.
당장에 편한 대로만 프로그램을 만들다보면 결국에는 너무 지저분하고 복잡해 손댈수없다.

05 성적표 Ver 3.6 - 예외 처리의 추가
원래 예외처리는 프로그램을 처음 설계할 때부터 함께 고민해야 할 주제.
프로그램에 기능을 추가하는 것과 동일하게 중요한 부분.

C++에서 제공하는 예외 클래스
모든 예외 클래스는 exception클래스의 자식 클래스.
exception:최상위 예외 클래스 <exception>
bad_alloc:new연산자가 메모리 할당에 실패했을 때 던진다. <new>
bad_cast:dynamic_cast연산자가 형변환에 실패했을 때 던진다. <typeinfo>
invalid_argument:잘못된 인자를 입력한 경우. <stdexcept>
length_error:제한한 길이를 넘을 때. <stdexcept>
overflow_error:오버플로우가 발생한 경우. <stdexcept>
range_error:정해진 범위를 넘어 섰을 때. <stddexcept>
클래스들을 직접사용하거나 자식 클래스를 만들어 사용할 수 있다. 헤더파일 포함.

파일을 열지 못하는 경우에 예외 던지기
TextOutput이나 HTMLOutput클래스의 생성자에는 파일을 여는 코드가 있다.
fout.open(filename.c_str());
파일을 여는데 실패하더라도 자동적으로 예외가 던져지지는 않는다.
직접 예외를 안던지면 파일을 열지 못했는데도 계속 진행하면 문제가 생길수 있다.
처음할 일은 예외 처리를 효율적으로 할 수 있게 예외 클래스를 만드는 일이다.
exception클래스를 상속받아서 만들면 여러가지 장점을 갖게 된다.
C++에서는 많은 예외 클래스들을 제공하는데 모두 exception클래스를 부모로 한다.
exception클래스의 자식 클래스로 만들게 되면 다형성을 이용해 함께 다룰 수 있다.
25_23
MyException.h
예외 클래스를 사용해 TextOutput클래스의 생성자를 고친다.
25_24
TextOutput.cpp HTMLOutput.cpp

예외를 받아서 처리하기
TextOutput의 생성자에서 던져진 예외를 받을 수 있는 곳은 두군데.
TextOutput객체를 생성하는 Students::Showll()함수에서 받을 수도 있고,
Students::ShowAll()함수를 호출하는 main()함수에서 받을 수도 있다.
예외를 받아서 어떻게 처리할지 아는 곳에서 받으면 된다.
main()에서 처리했는데 이유는 "이 예외를 받아서 예외 내용을 사용자에게 보여줘야 한다"
라는 사실을 알고 있기 때문.
25_25
main.cpp
MyException클래스를 만들 때 exception클래스를 상속받아 가능하다.
테스트는 파일을 읽기 전용으로 바꾼다음에 텍스트로 저장하면 예외처리 확인.
사용자에게 문제의 발생 사실과 구체적인 원인을 알려주었고,
계속해서 프로그램을 사용할 수 있으면 높은 점수를 받을 수 있다.
프로그램이 종료되면 입력한 자료들이 잃어버릴 수 있으므로.

List클래스에 예외 처리 추가하기
List클래스의 멤버 함수로 넘어온 인자가 올바른 것인지 검사하는 코드를 추가.
포인터를 많이 사용하는 코드에는 문제가 발생하기 쉬우므로 인자를 엄격하게 검사.
잘못된 인자가 넘어오는 경우는 예외라기보다는 버그다.
List클래스에서는 InsertNodeAfter()와 RemoveNode()인자에 대한 검사를 추가함.
25_26
list.cpp
인자 node가 NULL인 경우 invalid_argument예외를 던진다.
예외 클래스 중 하나로 잘못된 인자를 상징하는 예외 클래스.
exception클래스의 자식이기 때문에 main()의 catch블록에서 받아 처리.

문자열 끝의 337은 뭐죠?
개인적으로 337은 ~에서 발생한 예외라고 알아두면 나중에 발생했을 때 쉽게 알 수 있다.

NULL인지만 검사하면 되나요?
NULL이 아니더라도 잘못된 포인터일 수 있다. 이미 해체된 곳일 수도 있다.
사실 NULL이 아니면서 잘못된 포인터를 구분해내기가 힘들다.
하지만 운영체제에서 제공하는 방법을 사용하면 모든 잘못된 상화을 판별할 수 있다.
윈도우즈 프로그래밍을 공부하면 Win32 SEH에 대해 공부하면 알 수 있다.
IsBadWritePtr()과 같은 API를 공부하는 것도 좋다.

예외에 안전한 코드 만들기
Students::AddStudent()함수에서는 예외 때문에 메모리 릭이 발생할 수도 있다.
학생 객체를 동적으로 할당하는데 중간에 예외가 발생해 종료하면 객체를 잃어버리기 떄문.
예외를 받은 후에 다시 던지는 방법.
25_27
students.cpp
이렇게하면 메모리 릭은 발생하지 않고 예외 객체도 AddStudent()함수 밖으로 전달됨.
사실 이런 경우에는 스마트 포인터를 사용하는 것이 훨씬 권장할만한 방법.
Students::ShowAll()함수도 출력 객체를 동적으로 할당하므로 스마트 포인터로 대비.
25_28
students.cpp
함수 끝에서 delete연산자를 사용해 출력 객체를 해제하던 코드는 사라짐.

cin 객체 안전하게 사용하기
cin 객체 때문에 프로그램이 오동작하는 경우가 있다.
'a a a a'처럼 정보를 입력하면 cin객체가 파업을 한다.
cin 객체가 숫자가 들어오기를 기대하는데 문자를 입력하면 파업을 선언한다.
cin객체는 우리의 요구를 계속 무시하게 되어 무한히 메뉴만 출력함.
cin객체를 사용해 숫자 값을 입력받을 일이 있을 때 항상 사용해야 한다.
Student::Input()과 EngStudent::Input()
25_29
student.cpp
cin객체를 사용해 값을 입력 받고 cin 객체의 상태를 점검한다.
파업 상태라면 cin객체를 초기화하고 다시 입력 받는다.
정상 상태라면 입력을 끝낸다.

06 프로젝트 리뷰
프로그램을 만들 때는 아주 조금씩 점진적으로 개발해나가는 것이 중요하다.
한 가지 기능을 추가할 때마다 프로그램이 잘 동작하는지 테스트하는 것도 중요하다.
소스 코드의 중복을 최대한 줄여야 한다는 점도 매우 중요.
함수, 상속, 다형성 등은 중복을 줄일 수 있는 훌륭한 무기.

*/