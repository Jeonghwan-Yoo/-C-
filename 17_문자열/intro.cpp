/*
01 문자열 사용의 기본

왜 문자열을 사용해야 할까
사람의 이름이나 주소 등을 보관할 수 있는 유일한 방법.

c스타일과 c++스타일의 문자열 사용법 존재 이유
문자열을 보다 객체지향적으로 사용할 수 있게 개선한 방법이 C++.
두 스타일을 조화롭게 사용해야 한다.

C스타일의 문자열
C 스타일 문자열 사용의 대략적인 구조
"문자열이 어떤 방식으로 저장되는가"', "어떤 방식으로 문자열을 처리하는가"
C스타일의 문자열은 '문자의 배열'에 보관한다.
문자열을 처리할 때는 C++에서 제공하는 함수를 사용한다.

문자열의 길이와 복사 -strlen, strcpy
17_1.cpp
strlen()은 인자로 문자열을 넣어주면, 문자열의 길이를 계산해 반환해준다.
strlen()은 NULL문자를 제외한 길이이므로 +1을 해줘야한다.
strcpy()함수는 뒤쪽의 문자열을 앞쪽의 문자열로 복사하게 한다.
src는 '원본 문자열', dest는 '쓰레기 값' 
src가 가리키는 메모리의 내용을 dest가 가리키는 메모리에 복사한다.
strcpy()에서 첫번째 인자가 가리키는 메모리는 원본 문자열을 모두 복사할 수 있는 충분한 크기.

문자열의 비교와 결합 - strcmp, strcat
17_2.cpp
strcat()은 인자 두 개를 받는데, 두 인자가 나타내는 문자열을 합쳐서 하나의 문자열로 만든다.
새로운 문자열은 첫번째 인자가 가리키는 메모리에 보관이 된다.
strcat()의 첫번째 인자가 가리키는 메모리의 크기는 충분히 커야한다. 합쳐도 될 정도.
str1의 NULL문자있는 곳에 str2를 붙히는 것.
strcmp() 두 개의 문자열을 인자로 받아 같으면 0을 반환한다.
이 함수는 인자로 넘겨져 온 두 문자열을 한 글자씩 비교한다.
NULL문자가 나올때까지 비교에 성공하면 최종적으로 0을 반환한다.
앞의 문자열이 크면 양수, 뒤의 문좌열이 크면 음수.

문자열 다시 보기
문자열을 저장하기 위해서는 메모리가 필요하고 여러개 모여있기 때문에 큰 크기의 메모리를 요구.
메모리를 얻을 수 있는 방법은 '배열의 정의'와 '동적 메모리 할당'
char str[] = "I'm string.";
컴퓨터는 'str'을 문자열로 받아들일 수 있다.
str이라는 배열의 이름은 &str[0]과 같다. 첫번째 문자의 주소.
즉, 문자열의 첫번째 바이트의 주소를 사용해서, 전체 문자열을 지칭한다.
void Function(char* p);가 있다고 하자.
호출할 수 있는 방법은 두가지가 존재한다.
//char 변수의 주소를 넣어준다.
char c = 'A';
Function(&c);
//문자열의 시작 주소를 넣어준다.
char s[] = "ABCDE";
Function(s);
그러면 이 함수 안에서는 문자인지 문자열인지 잘 모를 수 있다.
그래서 개발자들끼리 잘 약속해두어야 한다. 주석을 통해서
//p:문자열을 넣어야한다.
void Functoin(char* p);
즉, char*타입의 변수가 가리키는 곳은 문자인지 문자열인지 모른다.
물론 대부분은 문자열이다.
cout객체 역시 이런 생각이어서 char변수의 주소를 넘겨도 문자열처럼 취급한다.
17_3.cpp
cout 객체는 당연히 문자열이라고 생각하고, NULL문자가 나올 때까지 모든 문자를 출력.
&c를 넘겨주었을 때도 cout은 문자열의 주소라고 생각한다. 그래서 NULL나올때까지 출력.
그 결과 변수 c 뒤에 있는 메모리의 쓰레기 값들을 출력한다.
즉, char* 타입의 변수가 문자인 경우에도 문자열을 가리키고 있다고 오해받을 수 있다.

문자열 리터럴 다시 보기
문자열 리터럴은 'abcde'와 같은 문자열 상수를 말한다.
char* p ="abcde"; 'a'의 주소가 400이라고하자.
변수 p에 들어가는 값은 무엇일까?
문자열 리터럴을 메모리의 어딘가에 보관하고, p는 그 메모리의 시작 주소를 가리키게 된다.
문자열 리터럴을 '리터럴을 저장한 메모리의 시작주소'로 해석한다.
예로 "abcde"라는 리터럴은 컴퓨터 입장에서 'char* 타입의 400이라는 값'으로 해석.

문자열 리터럴을 저장하는 곳
문자열 리터럴도 스택이나 자유 저장소와는 별도의 메모리 영역에 보관한다.

리터럴을 이용한 재미있는 코드
char c ="abcde"[3];
c는 'd'라는 값을 갖게 된다.
char* p = "abcde";
char c = p[3];

문자열 리터럴이 너무 길어 두줄로 나누어 쓰는 경우.
char* p = "This is string is too long."
"So I will split into 2 lines.";

C++스타일의 문자열
C++문자열은 보다 사용하기 편하고 안전하다.

string의 의미
string은 클래스가 아니라 basic_string이라는 클래스는 typedef해서 재정의한 타입.

C++스타일 문자열 사용의 대략적인 구조
C스타일은 메모리를 할당하고 ,처리하고, 다시 해제해주는 일을 직접해야 되지만,
C++는 간단한 명령으로 동일한 일을 할 수 있고, 안전하고 신뢰할 수 있는 결과.
사실 그 근본은 동일하고 내부적으로는 문자열을 사용하고 있다.
C++스타일의 문자열이란 string이라는 이름의 클래스를 의미한다.
문자의 배열을 멤버로 가지면서, 동시에 처리할 수 있는 변수도 가지고 있다.

문자열 생성
문자열을 생성하고 초기화하는 방법과 출력하는 방법.
17_4.cpp
타입으로 'string'을 사용해서 변수를 정의하면 된다.

클래스와 객체
string은 클래스고, s는 객체가 된다. 타입과 변수의 관계처럼.

문자열의 길이와 복사
17_5.cpp
그냥 문자열 객체끼리 대입하면 복사가 된다.

C++스타일의 문자열 복사가 수행속도도 더 빠른가요?
수행 속도에 있어서 장점을 갖지는 않는다. 내부적으로는 동일한 작업을 하기 때문에.

길이를 재는 방법
17_6.cpp
문자열 객체의 이름에 점을 찍고 size()함수를 호출하면 문자열의 길이를 반환한다.
함수를 호출해야 하므로 ()까지 붙여주는 것.

문자열의 결합과 비교
17_7.cpp
기본 타입을 사용하는 것과 비슷하다.
덧셈 연산자를 통해 두 문자열 객체를 더해주면 문자열이 결합하고 다시 str1에 대입.
비교하는 부분도 관계연산자를 사용해 쉽게 비교할 수 있다.

문자열의 검색
문자열 내에서 단어(sub-string)을 찾는 기능.
17_8.cpp
find()를 사용하면 쉽게 단어를 검색할 수 있다.
찾고 싶은 단어를 인자로 넣어주면, 자신 안에서 그 단어를 찾아준다.
찾으면 단어의 옵셋을 반환한다.

옵셋
기준점으로부터의 거리를 의미한다.
문자열의 시작에서 33바이트의 거리만큼 떨어진 곳에 'official'이라는 단어가 있다는 것이다.
배열의 표기법처럼 인덱스로 생각해 0이 시작.

strstr()
C++에서 제공하는 문자열 함수중에 비슷한 일을 하지만, 옵셋을 반환하는 대신에
찾은 위치의 주소를 반환한다.

문자열의 일부분 얻기
만약 파일의 확장자(.jpg)만을 얻어내고 싶다면 어떻게 해야 할까?
17_9.cpp
substr()은 두 개의 인자를 받는데, "a번째 옵셋에 있는 문자부터 b개를 읽어오라"는 뜻.
즉, 뒤에서 3번째부터 3글자 얻어와라.
이스케이프 문자열은 1바이트로 취급.

02 문자열의 사용
C스타일과 C++스타일의 조화로운 사용
서로의 스타일로 변환해줄 필요가 있다.
C스타일의 문자열은 암시적인 형변환을 통해 C++스타일의 문자열로 변경할 수 있다.
17_10.cpp
C스타일의 문자열을 string객체에 대입하면 문자열을 string객체로 복사한다.
각자를 수정해도 영향을 받지 않는다. 별개의 복사본이라.
17_11.cpp
C스타일의 문자열을 string클래스에 대입했을 때는 '문자열의 복사'가 일어난다.

반대로 string객체에 보관한 문자열을 C스타일의 문자열로 바꾸는 방법.
17_12.cpp
c_str()은 cppstyle객체 안에 보관한 문자열의 주소를 반환한다.
이 문자열은 여전히 cppstyle의 소유며, 오직 익는 용도로만 사용할 수 있다.
cstyle을 사용해서 cppstyle객체 안에 보관한 문자열을 읽는 것은 가능하나 변경은 불가능.
그래서 const속성을 넣어준 것이다.

완전히 복사본을 얻고 싶은 경우
17_13.cpp
1)c_str()함수를 사용해서 문자열의 포인터를 구할 수 있다. 그리고 이 포인터는 읽기 용도.
2)문자열의 본사본을 만들고 싶다면, 구해낸 포인터로 strcpy()함수를 호출하면 된다.

문자열의 입력
17_14.cpp
만약 cs배열의 크기를 넘어서면 엉뚱한 메모리 영역까지 덮어 써지게 된다.
다른 변수 소유의 메모리 영역을 침범해서 써버리는 것이다.
프로그램이 비정상적으로 종료하거나 엉뚱한 곳의 코드가 실행될 수도 있다.
해킹할 때도 많은 양의 문자열을 입력해서 자기가 원하는 코드가 실행되게 만들 수도 있다.
반면에 string클래스를 사용한 경우에는 아무리 양이 길어도 모두 받아들일 수 있으므로 안심.
하지만 >> 연산자를 사용해서 문자열을 받으면 공백을 포함한 문자열을 입력 받을 수 없다.

버퍼 오버플로우 공격
메모리의 크기를 넘는 많은 양의 문자열을 입력하는 해킹 방법을 버퍼 오버플로우 공격이라고 한다.
버퍼란 메모리의 다른 이름이라고 생각할 수 있는데 임시 저장 창고 역할.

공백을 포함해서 입력 받으려면 getline()을 이용한다.
17_15.cpp
C++의 스타일의 경우
getline(cin, cpps);
getline은 보통 함수고, cin객체에게 입력을 부탁한다. 문자열을 입력받을 객체는 cpps다.
C의 스타일의 경우
cin.getline(cs, 20);
cin객체에게 입력을 부탁해 그의 멤버인 문자열 입력함수를 호출한다. 
cs는 문자열을 입력받을 메모리의 주소고 20은 문자열을 입력 받을 메모리의 크기다(NULL포함)
그래서 실행하면 19자만 입력되고 마지막은 NULL.
그래서 C스타일의 문자열을 사용하는 경우에는 getline()이 더 안전하다.

cin객체는 자기 자신의 상태를 관리하는 능력이 있다.
그래서 19자를 초과하면 cin객체는 자신의 상태를 '실패'로 놓는다.
실패상태라 그다음 작업을 올바르게 하지 않는다.
실패상태를 지워주기 위해서는 clear()함수를 이용한다. 그럼 올바른 작동.
cin.getline(cs, 20);
cin.clear();
getline(cin, cpps);

*/