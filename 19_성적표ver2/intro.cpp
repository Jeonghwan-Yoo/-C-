/*
01 성적표 Ver 2.0 - 구조체와 배열의 사용
기능은 강해지고 소스 코드는 간결해진다.
19_1.cpp
19_2
19_1.cpp
배열을 사용하기 때문에 if 명령이 사라졌다.
19_3
19_1.cpp
구조체와 배열말고는 달라진 것이 없지만, 많은 학생을 허용할 수 있다. 그리고 기존 골격은 같다.
동적메모리는 처음에 입력한 값으로 메모리를 할당한다.
그것보다 사용자의 입력에 맞춰서 가변적으로 메모리를 조금씩 늘려갈 필요가 있다.
프로그램이 커지게 되면 모든 기능을 main()에 넣는 것은 비효율적.

02 성적표 Ver 2.2 - 함수와 파일로 나누기
프로그램의 주요 기능들을 함수로 나누는 작업.
main.cpp
나누어진 함수들을 조금 수정해서 여러 파일에 나누는 작업.
메뉴를 보여주고 선택받는 코드는 ShowMenu()함수로 옮겼다.
학생 정보를 입력 받는 코드를 InsertStudent()함수로 옮겼다.
성적을 출력하는 코드를 ShowAll()코드로 옮겼다.
19_4
main.cpp menu.h student.h 
19_5
menu.cpp 
19_6
student.cpp
함수 밖에서 변수를 정의하여 모든 함수에서 접근가능하게 만들었다.
이전 버전과 동일한 기능을 하면서 소스 코드의 구조만 바뀐 것.
기존에는 다른 성격의 소스 코드들이 뒤섞여 있어서 전체적인 흐름을 읽는 것도 어려웠고,
기능을 수정하면서 다른 기능까지 영향을 미칠 염려가 있었다.
필요한 부분을 찾기도 힘들었고, 내용이 섞이기도 한다.
1)하나의 함수가 하나의 기능만을 갖게 만들자.
파일을 나누는 것도 비슷한 효과.
2)하나의 파일에는 하나의 주제와 관련한 함수들만 모아놓자.
파일은 담장과 같은 역할로 다른 파일에 숨기는 역할을 한다.
3)파일과 파일의 관계는 서로 다른 동네와 비슷하다. 한 파일의 내부 사정은 다른 파일에 숨겨지고,
영향을 미치지도 않는다.
또한 목적을 수정 사항에도 잘 견디도록 하는 데 두어야 한다.
완전한 것은 없으므로 계속 기능을 추가하고 수정할 것이므로 하나의 구조로는 버티기 힘들다.

03 링크드 리스트
정해진 숫자 만큼의 학생 정보가 아니게 하려면 배열이아닌 링크드 리스트라는 새로운 자료구조.

원소와 노드
배열에서는 보관하는 공간을 원소(Element)라고 부르고
링크드리스트에서는 보관하는 공간을 노드(Node)라고 부른다.

링크드 리스트와 배열의 비교
일반적으로 구조체와 포인터를 사용해서 만들 수 있다.
배열에선 사용자가 배열의 시작 주소만 보관하고 있으면 된다.
링크드리스트에선 사용자가 첫번째 노드의 위치만 보관하고 있으면 된다.
배열에선 한 번에 다른 원소로 접근할 수 있다.
링크드리스트에서는 거쳐 거쳐 다른 원소로 접근할 수 있다.
어떤 원소에 접근하려고 할 때 배열은 덧셈 한 번만 하면 끝나지만,
링크드 리스트는 첫번째 노드부터 원하는 노드에 이르기까지 모든 노드를 한 번씩 거쳐가야한다.
링크드 리스트의 진정한 강점은 노드의 삽입과 삭제가 훨씬 간단하다는 점.
배열의 끝에 원소를 추가하려면 처음 배열을 만들 때부터 충분한 크기의 공간을 만들어야 한다.
링크드 리스트의 경우에는 새로운 노드를 만들고, 마지막에 연결하면 된다.
중간에 새로운 정보를 삽입하는 경우에는
배열은 공간이 남아있다는 가정에서 원하는 위치 이후에 값을 밀어야 된다.
링크드 리스트는 연결을 끊고 그자리에 새로운 정보를 연결하면 된다.
이렇게하면 무한대의 학생 정보를 보관할 수 있다.

왜 C++에서는 배열의 크기를 동적으로 늘릴 수 없을까?
배열은 모든 원소들이 차례대로 줄지어 위치하는 구조를 가진다.
마지막 원소 뒤의 공간을 늘리면 그 공간을 다른 변수가 사용하지 않았다는 보장이 없다.
배열이 위치한 뒤쪽의 공간을 다른 변수가 사용하고 있다면 배열을 확장하는 것은 불가능하다.

링크드 리스트의 구현
구조체의 설계
링크드 리스트를 구현할 때 제일 먼저 해야할 것은 노드 구조체를 설계하는 것이다.
노드 구조체는 두 가지 정보가 있어야 한다.
노드에 보관할 정보와 연결된 노드의 위치.
19_7
list.h
prev, next멤버는 자신의 앞뒤에 있는 노드를 가리키고, std멤버는 학생의 정보를 보관한다.
제일 앞쪽에 있으면 prev는 NULL, 제일 뒤쪽에 있으면 next는 NULL.
node1.prev:NULL        node2.prev:node1       node3.prev:node2
node1.next:node2       node2.next:node3       node3.next:NULL
node1.std :data        node2.std :data        node3.std :data
하지만 Student변수 말고 다른 정보를 담고 싶은 경우에는 링크드 리스트를 사용할 수 없다.
만약 모든 타입의 정보를 담을 수 있게 만든다면 다른 프로젝트에서도 재사용할 수 있을 것이다.
19_8
list.h
void*는 모든 타입의 포인터를 보관할 수 있다.
나중에는 Student변수를 동적으로 할당한 후에 그 주소를 노드의 data 멤버에 대입하면 된다.
data멤버를 사용해서 동적으로 할당한 Student변수를 가리키게 한다는 것이다.
19_9 링크드 리스트의 구현
list.h
연결한 노드들 중에서 제일 앞의 노드를 가리키는 것이 List구조체가 하는 일의 전부다.
head멤버가 첫번째 노드를 가리키는 역할. 헤드노드(Head Node)라고 부른다.
1)head를 만들어 노드첫번째를 가리키게 하는 방법
2)head노드를 따로만들어 첫번째노드를 가리키게하고 마지막노드를 헤드를 가리키게하여 환형으로.
둘의 차이점은
head가 비어있는 노드를 가리킨다는 점이다.
헤드 노드가 정보를 보관하기 위한 용도로 사용되는 것이 아니라 그냥 헤드 노드의 위치를 차지.
처음 링크드 리스트를 생성할 당시부터 헤드 노드는 맨 앞자리를 차지하고 있는 것이다.
리스트를 환형(Circular)로 구성했다는 점이다.
시작과 끝 노드를 서로 연결했기 때문에 시작과 끝 노드라는 개념이 존재하지 않는다.

모든 타입을 담는 법
void*는 모든 타입의 포인터를 담을 수 있다. 왜냐하면 암시적으로 형변환할 수 있기 때문에.
보관한 값을 꺼내서 쓸 때는 다시 원래의 타입으로 명시적인 형변환을 해야 한다.
잘못 형변환하면 위험할 수 있으므로 권장하진 않고, 템플릿(template)을 이용하는 것이다.

단일 링크드 리스트와 이중 링크드 리스트
이중 링크드 리스트는 자신의 앞쪽 노드와 뒤쪽 노드를 모두 가리키고 있는것.
단일 링크드 리스트는 자신의 뒤쪽 노드만 가리키는 경우로, 뒤쪽으로만 탐색하는 것이 가능하고,
역방향으로는 탐색할 수 없다.
반면에 자원을 절약할 수 있다.

CreateList() - 링크드 리스트의 생성 및 초기화
리스트를 생성하고 초기화해주는 함수다.
아무런 정보도 가지고 있지 않은 헤드 노드가 존재한다.
이 함수에서 하는 일은 List와 Node구조체 변수를 하나씩 생성해 적절히 초기화하는 것.
List변수는 헤드 노드를 갖게 만들고, 헤드 노드는 자기 자신을 가리키게 만들면 된다.
19_10 CreateList() 함수의 구현
list.cpp

InsertNodeAfter() - 노드의 추가
리스트에 새로운 노드를 추가하는 함수이다.
두 개의 노드 사이에 새로운 노드를 삽입하는 것.
앞쪽 노드의 next멤버와 뒤쪽 노드의 prev 멤버가 새로운 노드를 가리켜야 한다.
새로운 노드의 prev, next멤버 역시 전후의 노드를 가리키면 된다.
19_11 InsertNodeAfter() 함수의 구현
list.cpp
before, after를 안하면 복잡한 코드가 만들어 진다.
새노드가 리스트의 끝에 삽입되건, 앞에 삽입되건, 중간에 삽입되건 상관없이 쓸 수 있다.
이유는 항상 자리를 지키고 있는 빈 헤드 노드와 환형 구조 때문이다.
선형 구조였다면 앞, 뒤, 중간이라는 개념이 있지만 환형이기 때문에 항상 중간에 삽입하는 꼴.
빈 헤드 노드가 항상 자리를 지키고 있기 때문에 모든 노드가 없어지는 경우를 처리할 필요 없다.

RemoveNode() - 노드의 제거
노드를 제거하는 함수이다.
19_12 RemoveNode() 함수의 구현
list.cpp
앞 뒤 중간 상관없이 동일한 방법으로 노드를 제거한다.

노드 탐색하기
모든 노드를 탐색하는 방법.
만든 링크드 리스트를 사용하는 사람이 노드 구조체의 멤버들을 사용해서 직접노드들을 하나씩 탐색.
19_13 모든 학생의 이름 출력하기
list.cpp
기본이 되는 아이디어는 current 변수를 사용해서 계속적으로 다음 노드를 가리키는 방식을 사용.

RemoveList() - 링크드 리스트의 소멸 및 정리
기본적인 아이디어는 일단 모든 노드를 제거한 후에 마지막으로 리스트를 제거하는 것.
19_14 RemoveList() 구현
list.cpp
헤드노드를 처음에 제거하지만 list->head처럼 헤드 노드의 주소를 사용해도 괜찮다.
하지만 list->head->next처럼 헤드 노드의 멤버에 접근한다면 문제가 된다. 이미 소멸된 메모리.
이런 경우 자세한 주석을 달아서, 코드를 잘못 이해하거나 수정하는 일을 막아야 한다.

04 성적표 Ver 2.3 - 링크드 리스트의 사용
19_15
19_16
19_17
19_18
students.cpp
Setup()과 Teardown()는 main() 함수에서 프로그램이 시작하고 끝낼 때 호출해준다.
실질적으론 버그가 있어 수정본은 Ver 2.4

*/