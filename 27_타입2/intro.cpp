/*
01 연산자 오버로딩
만든 클래스를 C++의 기본 타입처럼 다룰 수 있는 방법.
클래스 객체끼리 덧셈, 클래스 객체를 직접 cout객체로 출력할 수도 있다.

왜 연산자 오버로딩을 배워야 할까
클래스를 기본 타입처럼 다루기 위해서는 제일 먼저 오버로딩(Operator Overloading)
C++에서는 연산자가 하는 일을 함수로 만들 수가 있다.
그리고 이 함수를 상황에 맞게 구현하는 일을 연산자 오버로딩이라고 한다.
복소수 Complex를 만들었다고 하자. 그리고 덧셈을 위해 Complex::Add()
Complex c1, c2, c3;
c3 = c1.Add(c2);
하지만 연산자 오버로딩을 하면
c3 = c1 + c2;
대부분의 연산자를 오버로딩을 할 수 있어서 매우 편리하다.

멤버 함수를 사용한 연산자 오버로딩
멤버 함수를 사용할 수도 있고 일반 함수를 사용할 수도 있다.

complex 클래스 만들기
27_1
complex.h

피연산자가 두 개인 연산자
C++에는 Binary Operators가 많이 존재한다.
기본적인 사칙연산이나 대입연산, 관계연산, 논리연산 등등 오버로딩을 할 수 있다.
제일 먼저 +연산자를 사용해서 두 Complex객체의 덧셈을 구현.
27_2
complex.h 27_2.cpp
Complex opeartor+(const Complex& right) {
	int real = this->real + right.real;
}
Complex는 c3, right는 c2, this는 c1이된다.

피연산자가 한 개인 연산자
++와 --가 대표적. 피연산자의 앞쪽이나 뒤쪽 모두 올 수 있고 두 가지 경우에 다른 의미.
27_3
complex.h 27_3.cpp
핵심은 전치연산과 후치연산의 경우를 별도의 함수로 만든다.
후치연산임을 알리기 위해 int타입의 연산자를 하나 두었다.
피연산자가 하나인 연산자들을 오버로딩할 때는 인자가 없는 원형을 사용해야 한다.

일반함수를 사용한 연산자 오버로딩
연산자를 오버로딩할 때는 일반 함수를 사용할 수도 있다.

+연산자 다시 정의하기
27_4.cpp
첫번째로 인자의 개수가 다르다.
Complex operator+(const Complex& left, const Complex& right) {}
Complex는 c3, left는 c1, right는 c2.
Complex클래스의 private멤버 변수에 직접접근하고 있다. 멤버 함수가 아니기 때문에 접근하는 것이 불가능.
오류가 발생한 것을 방지하기 위해 접근할 수 있게 해주어야 한다.
friend Complex operator+(const Complex& left, const Complex& right);
다음과 같은 함수 원형은 Complex클래스의 친구로 만들겠다는 뜻이다.
친구로 지정한 함수에서는 Complex클래스의 모든 멤버에 접근할 수 있게 된다.
일반 함수를 사용해 연산자를 오버로딩할 때는 friend키워드를 사용해 지정하는 것이 일반적.
접근자를 사용하면 굳이 friend를 사용할 필요는 없다.

클래스를 친구로 지정하기
클래스의 정의 안에서 적어주면 되는데, 이경우는 List클래스의 모든 멤버함수에서 Node클래스의 모든 멤버에 접근가능.
class Node {
	friend class List;
}

멤버 함수로 정의할 수 없는 경우
연산자를 오버로딩할 때 반드시 일반함수를 사용해야 하는 경우가 있는데 오른쪽 피연산자가 객체인 경우.
<<연산자를 오버로딩하는 경우
Complex c(10,5);
cout << c;
일반 함수를 사용하는 경우라면 일단 <<연산자를 오버로드하는 것이므로 함수의 이름은 operator<<.
왼쪽 피연산자는 cout객체이므로 ostream타입을 사용해 ostream&처럼 만든다.
오른쪽 피연산자는 Complex 객체이므로 const Complex&처럼 만든다.
void operator<<(ostream& o, const Complex& right)
멤버 함수를 사용한다면 두가지로 생각해 볼 수 있는데
//왼쪽 피연산자는 Complex, 오른쪽 피연산자는 cout인 경우에 호출된다.
void Complex::operator<<(ostream& o);
//양쪽 피연산자 모두 Complex인 경우에 호출된다.
void Complex::operator<<(const Complex& right);
결국 두 개의 피연산자 중에서 오른쪽 피연산자만 Complex인 경우는 멤버 함수를 사용해서 구현할 수 없다.
<<뿐만아니라 다른 연산자의 경우에도 적용되는 규칙이다.
<<연산자를 오버로딩해서 Complex객체를 cout으로 보내보자.
27_5.cpp
cout << c1 << "\n";
<<연산자를 동시에 사용할 경우에 좌측의 연산부터 수행한다.
cout << c1수식을 먼저 계산하고, 그 결과 값과 "\n"이 다시 <<연산을 수행한다.
즉, <<연산자를 여러 개 붙여서 사용할 수 있도록 만들기 위해서 cout객체를 반환해야 하는 것이다.

연산자 오버로딩의 규칙
오버로딩이 가능한 연산자
피연산자가 하나인 연산자
! : 논리 NOT연산
& : 주소를 얻는 연산
~ : 비트 단위 NOT연산
* : 포인터가 가리키는 곳의 변수를 의미하는 연산 Dereferencing
+ : 값에 +를 붙여주는 연산
++ : 1증가시키는 연산
- : 값에 -부호를 붙여주는 연산
-- : 1감소시키는 연산
형변환 연산자

피연산자가 두개인 연산자
, !=, %, %=, &, &&, &=, *, *=, +, +=, -, -=, ->, ->*, /, /=, <, <<, <<=, <=, =, ==, >,
>=, >>, >>=, ^, ^=, |, |=, ||, (), []

기타 연산자
() : 함수 호출 연산
[] : 배열의 원소를 가져오는 연산 Subscription Operator
new : 객체를 생성하는 연산
new[] : 객체의 배열을 생성하는 연산
delete : 객체를 해제하는 연산
delete[] : 객체의 배열을 해제하는 연산

반드시 멤버 함수를 사용해서 오버로드 해야하는 연산자
=, (), [], ->

오버로딩할 수 없는 연산자
. : student.name처럼 멤버를 선택하는 연산자
.* : (student.*fpn)()처럼 멤버에 대한 포인터를 선택하는 연산
:: : Student::MAX_NUMBER처럼 영역을 선택하는 연산
?: : a > b ? a : b처럼 사용하는 삼항 연산자
# : 전처리기에서 인자를 문자열로 바꾸는 연산
## : 전처리기에서 문자열을 결합하는 연산

기존 연산 방법을 바꿀 수 없다.
연산자 오버로딩을 할 때 피연산자들 중에 적어도 하나는 객체가 되야 한다.
int operator+(int left, int right); //2개다 정수다.
만약 이런 함수를 만든다면 정수의 덧셈 방법을 변경하는 셈이므로 혼란을 가져옴.
연산자의 우선 순위나 계산 순서를 변경하는 것도 불가능하다.
그러므로 오버로드된 함수의 반환 값을 결정할 때는 기존 연산 방식을 고려해야 한다.
대입 연산자(=)의 경우도 a = b = c = 100처럼 사용할 수 있으므로 반환값에 신경써야한다.

기존 연산자의 의미를 해치지 말자
기존 연산자의 의미에서 크게 벗어나지 않게 만드는 것도 중요한 일이다.
+연산자를 오버로딩하고 뺄셈을 수행하면 혼란스러운 코드.
연산자를 오버로드하는 목적은 어디까지나 클래스의 편리한 사용과 이해하기 쉬운 소스 코드의 생산.

02 클래스와 관련된 형변환
C++스타일의 형변환
명시적인 형변환을 할 때는 괄호를 사용했었는데 이 방법은 C언어에서 사용하던 방식이다.
C++에서는 이를 대체할 수 있는 4가지 종류의 형변환 연산자가 추가되었다.

왜 C++스타일의 형변환을 배워야 할까
C스타일의 형변환은 두가지 문제점이 있다.
첫번째로 C스타일의 형변환은 눈에 잘 띄지도 않고 틀을 사용해서 찾아내기도 힘이든다.
형변환 말고도 괄호를 사용하는 부분이 많기 때문이다.
C++스타일의 형변환은 눈에 잘 띄는 외관을 가지고 있어 한 눈에 알아보기 쉽다.
명시적인 형변환을 수행한다는 것은 암시적인 형변환이 불가능하다는 뜻이고 컴퓨터가 생각하기에 문제가 있다는 뜻.
두번째로 C스타일의 형변환은 형변환의 의도를 구별해내기가 힘들다는 문제점.
C++의 형변환 연산자는 그 용도에 따라서 안전한 형변환, const속성을 제거하는 형변환, 위험한 형변환,
클래스 타입간의 형변환 등으로 나누어져 있다.
그러므로 읽는 사람이 형변환의 의도를 쉽게 알아챌 수 있다.
컴퓨터 역시 작성한 사람의 의도를 파악할 수 있어 컴퓨터가 경고해주는 것이 가능.

const_cast
어떤 타입에서 const속성이나 volatile속성을 제거할 때 사용한다.
const int를 int타입으로 형변환하는 코드
const int ci = 100;
int i = const_cast<int>(ci);
i는 형변환된 값을 대입하는 곳. int타입으로 형변환하는 것이고 ci의 값을 형변환한다.
C스타일의 형변환에 비해서 작성자의 의도가 명확하게 드러난다.
컴퓨터도 const_cast의 의미를 알고 있기 때문에 다른 종료의 형변환을 시도하면 오류를 발생시킴.

volatile키워드
변수를 정의할 때 붙여줄 수 있다.
컴퓨터는 가끔씩 어떤 이유에서 변수를 상수로 만들어버리는 작업을 하는데 volatile로 지정한 변수는 열외가 된다.
대부분의 경우 변수를 상수로 만드는 작업은 프로그램의 성능을 높이는 데 도움이 되지만 문제를 일으키기도 한다.
나중에 다중스레딩과 관련된 주제를 배우면 알게 된다.

reinterpret_cast
일반적으로 허용하지 않는 위험한 형변환을 할 때 사용한다.
int a, b;
a = reinterpret_cast<int>(&b);
포인터를 정수로 변환하는 등의 작업이 이에 해당한다.
프로그램을 작성하다보면 어쩔 수 없이 이런 정류의 형변환을 사용하게 된다.

static_cast
가장 일반적인 형태의 형변환을 할 때 사용한다.
double타입을 char타입으로 형변환하는 데 사용할 수 있다.
double d = 30.0;
char c;
c = static_cast<char>(d);
명시적인 형변환이기는 하지만 대체적으로 안전한 형변환이다.
만약에 A타입에서 B타입으로의 암시적인 형변환이 가능하다면 static_cast를 사용해서 B타입에서 A타입으로 형변환가능.
int*타입은 void*타입으로 암시적인 형변환이 되기 때문에 가능하다.

dynamic_cast
유일하게 C스타일의 형변환으로 불가능한 형변환.
서로 상속 관계에 있는 클래스간에 형변환을 할 때 사용한다.
중요한 것은 형변환을 수행하는 동시에 형변환이 안전한 것인지까지 검사를 해준다.
27_6.cpp
27_7.cpp
dynamic_cast는 다운캐스트, 부모 클래스타입에서 자식 클래스타입으로 형변환할 때 유용하다.
다운 캐스트는 포인터나 레퍼런스가 가리키고 있는 객체의 실제 타입이 무엇이냐에 따라 안전할 수도 있고,
위험할 수도 있는데 dynamic_cast가 알아서 안전 여부를 검사해주기 때문이다.
포인터의 형변환이라면 NULL을 반환함으로써 문제 상황을 알릴 수 있지만,
레퍼런스의 형변환인 경우 어떤 특정한 값은 반환하는 것이 불가능하므로 bad_cast예외를 던진다.
bad_cast도 exception클래스를 상속 받았다.

비주얼 C++ 6.0사용자의 경우
예제가 제대로 동작하지 않을 수 있따. 표준을 완벽하게 준수하지 않기 때문에.

dynamic_cast와 RTTI
RTTI(Runtime Type Information)은 실행 시간에 객체의 타입에 대한 정보를 얻을 수 있는 기능.
dynamic_cast연산자가 pa1이 가리키고 있는 객체를 A인지 C인지 알아낼 수 있는 것도 RTTI 덕분.
비주얼 스튜디오는 기본적으로 RTTI기능을 사용하지 않게 설정되어 있다.
하는 일이 많은만큼 자체적인 부하(Overhead)를 가지고 있기 때문.
RTTI기능을 사용하기 위해선 솔루션 탐색기에서 '프로젝트->속성'메뉴에서 왼쪽트리에 'C/C++'과 '언어'를 선택한 후에
'런타임 형식 정보 사용'속성을 예(/GR)로 변경한다.
클래스 A는 아무일도 하지 않는 가상함수가 하나 있는데, dynamic_cast를 하기 위한 필요한 작업.
가상 함수가 하나도 없는 클래스는 dynamic_cast를 사용할 수 없기 때문.
이는 RTTI의 내부 구현과 관련되어있다.
클래스 B,C는 부모로부터 가상함수도 물려받으므로 dynamic_cast를 사용할 수 있는 것이다.

형변환 방법을 컴퓨터에게 알려주기
클래스 타입과 기본타입 간의 형변환을 가능하게 해주는 방법
Complex타입과 int타입간의 형변환이 암시적으로 이뤄지게 할 수 있다.

왜 형변환 방법을 컴퓨터에게 알려줘야 할까
컴퓨터가 그 방법을 모르기 때문이다.
double에서 int로 형변환 하는 것은 잘라내야된다는 것을 알고 있지만 Complex는 우리가 만든 것이어서 모른다.

내가 만든 클래스를 다른 타입으로 형변환하기
연산자 오버로딩을 통해 Complex타입을 int타입으로 형변환하는 방법
27_8
complex.h 27_8.cpp
형변환 연산자를 오버로딩한 것.
Complex타입을 int타입으로 형변환할 일이 있을 때는 이 함수가 호출된다.
double도 마찬가지다.

다른 타입을 내가 만든 클래스로 형변환하기
int타입을 Complex타입으로 암시적으로 형변환할 수 있게 만들어 보자.
인자를 가진 생성자를 사용하면 된다.
complex.h 27_9.cpp
int 타입의 인자를 가진 생성자를 만들기만 하면 많은 일이 가능해진다.
생성자를 사용해서 임시 객체를 생성했다고 할 수도 있고, 형변환이 이루어졌다고 생각해도 좋다.

암시적인 형변환은 개발자 모르게 수행되기 때문에 예상치 못한 상황에서 형변환이 발생해서 문제를 일으킬수도 있다.
이런 경우에 생성자 앞에 explicit키워드를 붙여주면 된다.
explicit키워드는 '명시적인'형변환만을 허용한다.
explicit Complex(int i)라고 고쳐보자.
명시적인 형봔한은 사용한 경우에만 int타입을 Complex타입으로 변환할 수 있다.
암시적인 형변환을 시도한 곳에서는 오류가 발생한다.
int i = 10;
Complex c(0,0);
c = i; //실패:암시적인 형변환 불가능
c = Complex(i); //성공
c = (Complex)i; //성공
c = static_cast<Complex>(i); //성공

연산자오버로딩은 어디까지나 클래스를 사용하기 편하게 만들고 소스 코드를 이해하기 쉽게 만들기 위한 목적.
연산자오버로딩은 Complex클래스나 문자열 클래스처럼 간편하게 사용할 수 있는 유틸리티 성격의 클래스들에게는 
유용하지만 일반적인 클래스들은 연산자 오버로딩을 필요로 하지 않는 경우가 대부분이다.

*/