/*
01 가상 함수를 사용한 다형성의 구현
Virtual Function을 통해 다형성이 완성된다.

언제 가상 함수가 필요할까
Shape클래스와 그의 자식들
도형은 원, 사각형, 삼각형이 될 수 있다.
도형클래스는 최상위 부모 클래스, 나머지는 자식 클래스.
23_1.cpp
Shape클래스는 일반적인 도형을 상징하는 클래스.
_x, _y는 모든 자식 클래스들에게 필요한 것.
멤버 변수의 경우에는 부모 클래스로부터 상속 받은 것을 그대로 사용할 수 밖에 없지만
멤버 함수의 경우에는 부모 클래스에서 받은 것을 자기에게 맞도록 새롭게 정의할 수 있다.

보관한 객체를 사용하기 그리고 문제점.
사용자가 원이나 사각형을 그려줄 때마다 Circle클래스나 Rectangle클래스의 객체를
동적으로 생성한다.
수십가지의 도형별로 배열을 만들고 관리하는 것은 비효율적이다.
대신에 이 모든 클래스들이 Shape클래스의 자식 클래스라는 점을 사용해서
하나의 배열에 모든 객체를 보관할 수 있다.
자식 클래스의 포인터는 부모 클래스의 포인터를 변환할 수 있다.
Shape*타입의 배열을 만들어 둔다면 모든 도형 클래스들의 객체를 그 배열에 보관할 수.
23_2.cpp
다양한 타입의 객체를 동적으로 생성한 뒤에 반환하는 포인터를 배열에 보관하고 있다.
자식 클래스의 포인터를 부모 클래스의 포인터로 변환한 것이기 때문에 문제 없다.
Circle* pc = new Circle(100, 100, 50);
shapes[0] = pc;
배열에는 객체들의 주소가 보관되어 있다.
여러 가지 타입의 객체를 하나의 배열에 담았기 때문에 간단히 호출할 수 있다.
23_3 각각의 클래스 배열을 만든 경우
//클래스별로 객체를 보관할 배열이 있어야 한다.
Circle* circles[10];
Rectangle* rects[10];
Triangle* triangles[10];
Ellipse* ellipses[10];
//클래스별로 화면에 출력하는 코드가 있어야 한다.
for(i = 0; i < 10; ++i)
	circles[i]->Draw();
for(i = 0; i < 10; ++i)
	rects[i]->Draw();
for(i = 0; i < 10; ++i)
	triangles[i]->Draw();
상속을 사용하는 것이 얼마나 편하게 해주는지 확인할 수 있다.
하지만 모든 줄이 Shape::Draw()함수를 호출했다. 
사실 우리는 객체의 맞는 타입의 Draw()함수를 호출하길 원한다.
이런 문제를 해결하기 위해 가상 함수를 사용해야 한다.

멤버 함수를 가상 함수로 만들기
가상 함수로 문제점 해결하기
23_4.cpp
virtual void Draw() const;로 고쳐씀으로써 해결된다.
Shape::Draw()함수를 가상 함수로 만들면 Circle::Draw()와 Rectangle::Draw()도
자동적으로 가상 함수가 된다.
virtual 키워드는 클래스의 정의 안쪽에서만 한 번 붙여주면 된다.
클래스 밖에서 함수를 정의할 때는 virtual 키워드가 필요 없다.

소멸자를 가상 함수로 만들기
만약에 소멸자가 있었다면 소멸자를 반드시 가상함수로 만들어야 한다.
virtual ~Shape();
그렇지 않으면 객체를 해제시킬 때 올바른 소멸자를 호출되지 않는다.
일반 멤버 함수와 동일하게 소멸자도 가상 함수로 만들어줘야만
올바른 소멸자가 호출될 수 있다.
즉, 클래스에 하나 이상의 가상 함수가 있는 경우에는 반드시 소멸자도 가상함수로.

다형성과 가상 함수
다형성이란 타입에 관계 없이 동일한 방법으로 다룰 수 있는 능력.
Circle이나 Rectangle객체들을 각각의 타입에 상관없이 Shape객체처럼 다룰 수 있는 능력.
다형성은 부품간의 조립, 객체간의 연결을 유연하게 해주는 원동력.
//도형을 원점으로 이동하는 함수
void Controller::MoveToOrigin(Shape* p){
	p->Move(0,0);
	p->Draw();
}
Circle객체와 Rectangle 객체 모두 이 함수의 인자로 전달할 수 있다.
Shape클래스를 상속 받은 클래스의 객체라면 어느 것이나 사용할 수 있다.

C++와 다형성
부모 클래스의 포인터로 자식 객체를 가리킬 수 있다는 점과 이런 경우에도 가상 함수를 
통해서 알맞은 자식 클래스의 함수가 호출된다는 점이 다형성을 지원하는 C++의 기능.

동적 바인딩
바인딩이란 함수를 호출하는 명령과 실제로 호출되는 함수를 짝지어 주는 일을 말한다.
void Func(Shape* pc){
	pc->Draw();
}
pc가 가리키고 있는 객체에 따라서 어떤 Draw()가 호출될 지 모른다.
이렇게 프로그램을 실행한 후에야 어떤 함수를 호출하는지 알 수 있는 경우를 
동적바인딩(Dynamic Binding) 혹은 후기 바인딩이라 한다.
반대로 
Circle c;
c.Draw();
프로그램이 실행되지 않은 상태에서도 어떤 함수가 호출될지 명백하게 알 수 있는 경우를
정적 바인딩이라고 한다.

오버로딩과 다형성
오버로딩도 다형성의 한 종류다.
하나의 이름을 사용하지만 인자에 따라서 여러 가지 다른 함수들이 호출.
오버로딩의 경우에는 프로그램을 실행시켜보지 않아도 인자만 보면 알 수 있다.
인자에 의해서 호출될 함수를 결정하는 경우를 컴파일 시간 다형성 (Compile-time 
Polymorphism)이나 인자와 관련된 다형성(Parametric Polymorphism)이라고 한다.
반면에 가상 함수와 같이 객체의 타입에 따라서 호출될 함수를 결정하는 다형성을
실행 시간 다형성(Run-time Polymorphism)이라고 부른다.

문서 저장 클래스에 다형성 적용하기
DocWriter와 HTMLWriter 클래스의 수정
23_5.cpp
HTMLWriter객체를 생성하면서 넣어준 것을 그대로 사용했지만 DocWriter::Writer()호출.
Writer()멤버 함수가 가상 함수가 아니기 때문이다.
객체 타입에 맞게 HTMLWrtier::Writer()함수를 호출하게 한다.
23_6.cpp
DocWriter.h HTMLWriter.h
HTML형식으로 문서가 저장되었다.
Write()함수가 가상 함수기 때문에 실제 객체 타입에 맞는 멤버 함수가 호출됨.
HTMLWriter 객체를 완벽하게 DocWriter객체처럼 다룰 수 있게 된 것이다.

02 오버라이딩
순수 가상 함수
부모 클래스의 멤버 함수를 자식 클래스에서 재정의하는 것을 오버라이딩(Overriding)

순수가상 함수는 왜 사용할까
순수 가상함수는 만드는 법은 가상함수의 선언뒤에 '=0'을 붙여주면 된다.
virtual void Draw() const = 0;
순수 가상 함수는 함수의 정의 부분이 필요하지 않다.
함수의 원형만 가지고 있는 함수가 바로 순수 가상함수다.
정의가없으니 호출할 수도 없다. 하지만 자식 클래스에서 이 함수를 오버라이딩하게 함.
다형성을 사용해서 이 함수를 호출하는 것이다.

순수 가상 함수로 만들기
23_7.cpp
순수 가상 함수로 만들어준다고 해도 결과가 달라지지는 않는다.
Shape::Draw() 함수의 정의를 지워 오류가 생길 것 같지만
실제 객체의 타입에 맞는 Draw()함수를 호출하는 것이기 때문에 상관없다.
하나 이상의 순수 가상 함수를 가진 클래스를 추상 클래스라고 부르는데,
추상 클래스의 객체를 만드는 것은 불가능하다.
Shape s;
객체를 생성하려고 하면 오류가 발생.
'도형'이라는 것으로 머리 속에서만 존재하는 추상적인 개념.

콘크리트 클래스
Concrete Class는 추상클래스와 반대가 되는 개념.
객체를 생성해서 사용하기 위한 용도의 클래스.
추상 클래스는 객체 생성이 아닌 다형성을 위한 부모 클래스로서의 용도.

다양한 종류의 멤버 함수
멤버 함수의 종류는 일반적인 멤버 함수, 가상함수, 순수가상함수.
1)처음엔 그냥 멤버 함수로 만든다.
2)다형성을 이용해야 하는 경우라면 가상 함수로 만든다.
3)다형성을 위해서 함수의 원형만 필요한 경우라면 순수 가상 함수로 만든다.
무조건 일반적인 멤버함수로 만들다가 문제가 있으면 가상함수로 고치자.
자식 클래스들이 생기고 다형성을 사용해 이 클래스를 다뤄야하면 가상 함수로 만들자.
반드시는 아니지만 그 클래스를 사용해서 객체를 생성할 필요없고 함수의 원형만
있어도 충분한 경우라면 순수 가상 함수로 만드는 것이 좋다.
즉, "이 함수는 약속된 부분(인터페이스)으로서의 역할만 합니다"라고 알려주는 것과 같다.
Shape클래스도 처음엔 일반 멤버 함수였다가 Draw()함수만 가상함수로 바꿨다.
그리고 약속된 부분으로서의 역할을 강조하기 위해 순수 가상 함수로 바꿨다.

오버라이딩한 함수에서 부모 클래스의 함수 호출하기
오버라이딩을 하는 대부분의 이유는 부모 클래스에서 해주는 일에 추가적인 작업을 위해.
오버라이딩한 함수 안에서 부모 클래스의 함수를 호출함으로써 소스 중복을 피한다.
Circle::Draw()함수는 _x, _y의 값을 출력하는 것에 더해 _radius값을 출력하기 위해.
void Circle::Draw() const {
	Shape::Draw();
	cout << "[Circle] Radius = " << _radius << "\n";
}

오버로딩과 오버라이딩
오버로드된 멤버 함수
23_8.cpp
하지만 강아지 클래스에서 Eat()함수 중에 하나를 오버라이드하면 문제가 발생한다.
23_9.cpp
부모클래스에서 오버로드된 함수 중에 어느 것 하나라도 오버라이드하면 나머지 다른
함수들도 모두 사용할 수 없다.
꼭 호출하고 싶다면
dog1.Pet::Eat("milk");

오버로드된 생성자들
생성자는 오버라이딩의 대상이 아니지만 컴퓨터가 기본적으로 제공해주는 생성자에 대해
같은 규칙을 적용해 볼 수 있다.
사실 상속과는 관련은 없다.
23_10.cpp
생성자가 없다는 오류가 발생한다.
생성자를 하나 만든 순간에 컴퓨터가 제공해주는 디폴트 생성자를 사용할 수 없게 된다.
이런 경우에는 아무 일도 하지 않는 디폴트 생성자를 우리가 직접 추가해주어야 한다.

다형성을 이해해야 객체지향 프로그래밍을 이해할 수 있고 결국에는 보다 좋은 
프로그램을 보다 쉽고 빠르게 만들 수 있다.


*/