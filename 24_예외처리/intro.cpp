/*
01 예외 처리의 기본
왜 예외 처리가 필요할까
예외란 우리가 당연하다고 가정한 상황이 거짓이 되는 경우.
하지만 가정이 언제나 맞는 것은 아니다.
이런 경우에 예외가 발생했다고 표현하고 이런 상황을 올바르게 처리하는 과정을 예외처리.
1)컴퓨터에 사용 가능한 메모리가 부족한 경우
2)하드디스크에 파일을 쓰는데 하드디스크의 남은 용량이 부족한 경우
3)사용자가 범위 밖의 값을 입력하거나 존재하지 않는 파일의 이름을 입력하는 경우
버그나 오규 같이 개발자의 실수로 일어나는 문제점들과 예외를 구별할 줄 알아야 합니다.
컴퓨터의 리로스가 부족하거나 사용자가 잘못된 입력을 하는 등 프로그램 외적인 요인.
하지만 예외처리를 올바르게 하지 못해서 결국 오류가 이어졌다면 개발자의 잘못.
프로그램을 이런 예외 상황에 적절하게 대처할 수 있게 만들어야 한다.
프로그램이 죽는 이유는 예외처리를 제대로 하지 못했기 때문.
외적인 요인으로 발생하는 것이지만 프로그램이 오동작을 하게 되고 죽기까지 한다.
예외처리는 프로와 아마추어를 구분하는 기준이 될 수 있다.
'비정상 종료하지 않는 기능'이 필수적.

DynamicArray 클래스 다시보기
DynamicArray.h DynamicArray.cpp 24_1.cpp
protected이기 때문에 접근자를 사용해서 원소에 접근해야 한다.
생성자에서는 동적으로 메모리를 할당하고 소멸자에서는 메모리를 해제한다.
main()함수가 끝날 때 arr객체의 소멸자가 자동으로 호출되고 메모리를 해제.

반환 값을 사용한 예외 처리
SetAt()함수에서는 잘못된 인덱스를 받았을 때 자신을 호출한 곳에 문제발생을 알림.
이런 일은 함수의 반환 값을 통해서 이루어졌다.

예외 상황의 처리
DynamicArray.cpp 24_2.cpp
SetAt()함수안에서 인덱스를 비교한 후에 false를 비교해 문제가 없었다.
SetAt()함수에 잘못된 인덱스를 넘긴 사실은 '예외 상황'
SetAt()감지한 후에 예외 상황을 외부에 알리는 과정이 '예외 처리'
예외 상황이 발견되는 경우에 반환 값으로 그 여부를 알려주는 것이 전부.

반환 값을 사용한 예외 처리의 문제점
함수를 호출할 때마다 매번 반환 값을 비교해야 하는 번거로움이 있다.
24_3
void UseArray(DynamicArray& arr) {
	bool b;
	b = arr.SetAt(5, 100);
	if (!b)
		cout << "실패";
	b = arr.SetAt(8, 100);
	if (!b)
		cout << "실패";
	b = arr.SetAt(10, 100);
	if (!b)
		cout << "실패";
}
코드가 쓸데 없이 길어져서 읽기도 어렵고 일을 파악하기도 힘들다.
구조적인 예외 처리로 깔끔하게 해결할 수 있다.
다음 문제점은 함수가 이미 다른 용도로 반환 값을 사용하는 경우다.
GetAt()함수는 반환값을 사용해 원소의 값을 반환하고 있는데 반환 값으로 예외처리하면
bool GetAt(int index, int& value);
예외 처리 때문에 함수의 원형을 바꿔야되고 레퍼런스 인자를 사용하는 것도 불편하다.
1)본연의 소스 코드와 예외 처리 코드가 뒤엉켜서 지저분하고 읽기 어렵다.
2)예외 처리 때문에 반환 값을 본래의 용도로 사용할 수 없다.
이런 문제때문에 구조적 예외 처리를 사용해 효율적으로 처리할 수 있다.

윈도우즈의 SEH
구조적 예외처리 Structured Exception handling
윈도우즈 운영체제에 내장된 예외 처리를 말하기도 한다.

구조적 예외 처리
일반적으론 구조적 예외처리를 '예외 처리'라고 말한다.

반환 값을 사용한 예외 처리를 대체하자
C++에서는 세가지 키워드를 추가했다. throw, try, catch.
24_4
DynamicArray.cpp 24_4.cpp
throw는 예외를 던지는 명령이다. 문자열 리터럴이어서 const char* 타입.
정수를 던져도 되고 객체를 던져도 된다.
try,catch는 항상 짝을 이뤄서 사용하는데 catch블럭이 예외를 받는 곳이 된다.
catch블록은 오직 한가지 타입의 값만 받을 수 있다.
try는 예외가 던져지는 범위를 지정하는 역할을 한다. 
try안에서 발생하는 예외만 이어지는 catch블럭에 잡힌다.
예외가 던져지면 DynamicArray::SetAt()함수는 바로 실행을 종료한다.
그리고 실행의 흐름은 UseArray()함수의 catch블럭으로 이동한다. 예외도 전달됨.
const char* ex = "Out of Range!!!";
예외 처리와 관련한 코드도 잘 분리되어 있어서 지저분하지 않고 양도 줄어든다.
SetAt(),GetAt()함수는 더 이상 반환 값을 착취당할 필요가 없어졌다.
우선 throw에 의해서 예외가 던져지면 그 함수는 바로 종료된다는 사실.
throw에 의해서 던져진 예외는 함수를 뛰어넘어서까지 전달된다는 점.
하지만 잘못 사용하면 문제를 일으킬 수 있다.

예외 객체의 사용
현장에서도 기본 타입의 값을 예외로 던지는 경우는 거의 없고 대부분 객체를 던진다.

다양한 정보를 전달할 수 있다.
객체를 던질 때는 객체의 멤버 변수들이 모두 던져지는 것.
24_5
24_5.cpp DynamicArray.cpp MyException.h
MyException객체를 예외로 던지면 정보들이 모두 던져지는 셈.
예외를 받은 곳에서는 이 정보들을 사용해서 보다 구체적으로 파악할 수 있다.
arr1과 arr2의 주소가 포함되어 있기 때문에 어떤 객체가 예외를 던졌는지 알 수 있다.
info에는 예외가 발생할 당시의 인덱스가 담겨있다.
결과를 보면 arr2의 주소와 예외 객체에 담긴 주소가 일치한다.

다형성을 사용해서 일관된 관리를 할 수 있다.
객체를 예외로 던질 때도 다형성을 사용할 수 있다.
다형성을 사용하면 이 클래스들의 객체들을 MyException객체처럼 다룰 수 있다.
24_6
MyException.h DynamicArray.cpp 24_6.cpp
catch를 MeException&타입으로 하게되면 MyException, OutOfRangeException,
MemoryException객체 모두를 받을 수 있다.
자식 객체를 부모 클래스 타입의 레퍼런스로 가리킬 수 있으므로.

구조적 예외 처리와 관련된 규칙
예외는 함수를 여러 개 건너서도 전달할 수 있다.
24_7.cpp
C()에서는 정수 값을 예외로 던진다. 던져진 순간 C()함수가 종료. B(), A() 종료.
그리고 catch블록으로 실행이 이동.
예외는 자신의 타입에 맞는 catch블록을 찾을 때까지 함수를 거슬러 올라간다.
알맞은 catch블록을 찾지 못하면 프로그램이 비정상 종료해버린다.
그러므로 main()함수에서는 반드시 모든 예외를 잡아주어야 한다.

예외를 다시 던지기
catch블록에서 잡은 예외를 다시 던지는 방법.
24_8
void A() {
	try {
		B();
	}
	catch(char c) {
		cout << "A() 함수에서 잡은 예외 = " << c << "\n";
		throw; //받은 예외를 그대로 다시 던진다. 다시 함수를 올라가 catch를 찾는다.
	}
}
throw라고만 적어주면 받은 예외를 다시 던지게 된다.
다시 던지는 이유는 이 예외를 자신이 받아서 처리했지만 외부에도 예외 상황을 알리려고.

catch가 여럿인 경우
하나의 try블록에는 여러 개의 catch블록이 따라올 수 있다.
24_9.cpp
try블록 안에서 예외가 던져지면 제일 앞에 있는 catch블록부터 시작해서 비교한다.
중요한 건은 앞쪽의 catch블록부터 비교를 수행한다는 점.
24_10
catch(MyException& ex) {
	cout << "MyException";
}
catch(OutOfRangeException& ex) {
	cout << "OutOfRangeException";
}
catch(...) {
	cout << "그 밖의 타입";
}
다형성 때문에 OutOfRangeException은 영원히 실행될 수 없다. MyException이 가로챔.
그러니 순서를 잘 고려해야 한다.

예외 객체는 레퍼런스로 받자
24_11 객체를 예외로 던지고 받는 경우
try {
	MyException e(this, "객체", 0);
	throw e;
}
catch(MyException ex) {
	cout << ex.description << "\n";
}
이 경우의 문제점은 불필요한 복사가 발생한다는 것이다.
catch블록이 시작되면서
MyException ex = e; MyException 클래스의 복사 생성자가 실행되면서 복사한다.
반면에 포인터나 레퍼런스를 사용하는 경우에는 불필요한 복사가 발생하지 않는다.
24_12 포인터
try {
	MyException* p = new MyException(this, "객체", 0);
	throw p;
}
catch(MyException* pex) {
	cout << pex->description << "\n";
	delete pex;
}
포인터를 던지고 받을 때는 메모리 할당과 해제를 신경써야 하는 단점.
24_13 레퍼런스
try {
	MyException e(this, "객체", 0);
	throw e;
}
catch(MyException& ex) {
	cout << ex.description << "\n";
}
MyException& ex = e;
레퍼런스를 사용한 경우에는 불필요한 복사가 발생하지 않고, 메모리관리도 신경 안써도됨.
앞으로 예외를 받을 때는 되도록 레퍼런스를 사용하자.

02 구조적 예외 처리 제대로 사용하기
예외에 안전한 코드 만들기

리소스를 정리하기 전에 예외가 발생한 경우의 문제점
구조적 예외처리에서 가장 빈번한 문제는 리로스를 정리하기 전에 함수가 종료되는 경우.
24_14.cpp
결국 A()함수의 앞에서 할당된 메모리가 해제되지 않는 문제가 발생했다.
메모리 할당 뿐만 아니라 함수의 끝에서 무언가 정리 작업을 해주는 경우라면 문제.

메모리 릭(Memory Leak)
메모리가 조금씩 새어 나가는 현상.
할당한 메모리를 해제하지 않을 때 발생한다.
리소스 릭
리소스는 일반적으로 메모리, 하드디스크와 같은 포괄적인 의미의 자원.
메모리 뿐만아니라 다른 종류의 자원이 새어 나가는 현상까지 통틀어 일컫는 용어.

소멸자로 리소스 문제 해결하기
함수가 종료될 때 그 안에서 정의된 모든 변수들이 소멸된다.
객체의 경우 소멸자까지 자동적으로 호출.
함수가 종료되는 경우에도 객체의 소멸자는 반드시 호출.
이것을 이용해 리소스를 해제하는 용도의 클래스를 만들 수 있다.
일반적으로 이런 용도의 클래스를 스마트 포인터(Smart Pointer)라고 부른다.
24_15.cpp
SmartPointer는 생성자에서 동적으로 할당된 메모리의 주소를 인자로 받아 멤버변수에 저장.
또, 소멸자에서는 보관한 주소를 사용해서 메모리를 해제하는 것 뿐.
SmartPointer객체를 생성하면서 동적으로 할당된 메모리의 주소를 인자로 넘겨준다.
함수가 어떻게 종료되건 객체의 소멸자는 반드시 호출되고, 메모리도 해제.
C++에서는 이런 용도의 스마트 포인터를 이미 제공한다. auto_ptr 클래스.

생성자에서 예외가 발생한 경우의 문제점
일반적으로 객체는 예외에 안전하다.
예외가 발생해도 객체의 소멸자가 반드시 호출되고 리소스도 모두 해제할 것이기 때문.
하지만 생성자에서 예외가 발생한 경우에는 가정이 깨지고 만다.
24_16
DynamicArray.cpp 24_16.cpp
DynamicArray객체의 소멸자가 호출되지 않았다.
즉, 생성자에서 할당한 메모리도 해제되지 않았다는 뜻.
왜냐하면 생성자가 올바르게 종료된 경우만 객체를 생성한 것으로 간주하기 때문.
객체가 생성되지 않았으니 소멸자도 호출될 일이 없다.

예외 다시 던지기
사실 생성자에서 예외를 던지는 것은 매우 바람직한 일.
생성자는 반환 값이 없기 때문에 예외를 던지는 것이 예외 상황을 알리는 유일한 수단.
24_17
DynamicArray.cpp
예외를 중간에 가로채서 필요한 정리 작업을 한 후에 예외를 다시 던지는 것.

소멸자에서의 예외는 반드시 막아야 한다.
객체의 소멸자에서 예외가 던져지는 경우에는 구조적 예외 처리의 내부적인 실행방식
때문에 프로그램이 비정상 종료할 수 있다.
소멸자 밖으로 예외가 던져지지 않게하려면 생성자처럼 모든 코드를 try로 감싸야 한다.
이렇게 잡아낸 예외는 절대로 소멸자 밖으로 다시 던져서는 안된다.
24_18
DynamicArray::~DynamicArray() {
	try {
		//메모리를 해제한다.
		delete[] arr;
		arr = 0;
	}
	catch(...) {
	}
}

C++에서 제공하는 예외 관련 기능
auto_ptr
auto_ptr클래스는 C++에서 제공하는 스마트 포인터.
24_19.cpp
auto_ptr클래스는 모든 타입의 포인터를 보관할 수 있다.
new int를 통해 int타입의 값을 하나 할당하고 그 주소를 p의 생성자로 전달.
이 메모리는 스마트 포인터에 의해 관리되므로 더 이상 신경안써도 된다.
auto_ptr<int> p(new int);
auto_ptr클래스의 객체를 정의한다. int변수를 가리킬 수 있는 auto_ptr이다.
p는 스마트포인터의 이름이고 동적으로 int타입 변수를 생성하고 그 주소를 
생성자의 인자로 넣는다.
연산자 오버로딩을 배우면 이런 클래스를 만들 수 있다.
 
auto_ptr의 한계
auto_ptr은 new[] 연산자를 사용해서 할당된 메모리의 주소를 보관할 수 없다.
new연산자를 사용해서 할당된 메모리만을 관리할 수 있다.
이를 보완하여 scoped_ptr이나 scoped_array라는 클래스도 있다.

메모리 할당 시에 발생하는 예외
동적으로 메모리를 할당할 때 컴퓨터에 충분한 메모리가 남아있지 않다면
new,new[]연산자는 bad_alloc이라는 예외를 던진다.
24_20.cpp
bad_alloc예외를 잡기 위해서는 new,new[]연산자를 사용해 메모리를 동적으로 할당하는
부분을 try블록으로 감싸줘야 한다. 그리고 catch블록준비.
만약 메모리가 부족해 할당을 못하면 bad_alloc예외가 발생하고 catch블록에서 잡는다.
bad_alloc클래스의 멤버함수 what()을 호출함으로써 예외에 대한 설명을 볼 수 있다.
중요한 건 new,new[]연산자를 사용할 때마다 반드시 예외처리를 해야한다.
실제 현장에서는 new,new[]를 사용하는 모든 코드에서 bad_alloc이 던져질 수 있다고 가정.

CMemoryException클래스
MFC를 사용한 윈도우즈 프로그래밍을 한다면 bad_alloc대신 CMemoryException을 사용.
C++은 아주 유연해 bad_alloc대신에 다른 객체를 던지는 것도 허용하는데
MFC의 경우에는 CMemoryException을 던지게 고쳐놓았다.


*/