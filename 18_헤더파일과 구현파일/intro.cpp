/*
01 헤더 파일과 구현 파일의 사용
프로그램의 크기가 커지면 여러 개의 구현 파일을 사용하는 것이 필수적.

왜 여러 개의 소스파일을 사용해야 할까
방대한 소스 코드를 한 파일에 담는 것은 불가능. 수정하기도 어렵다.
관련된 함수와 변수를 파일 단위로 모아 두면 필요할 때 찾아보기 쉽다.
하지만 다른 파일에 있는 내용을 참조해야 하는 경우가 생긴다. 하나로 합쳐지기 때문에
그래서 잘 맞물려서 돌아가게 해주어야 한다.
소스 코드를 헤더 파일과 구현 파일에 나누어 담는다.
실제적인 일을 하는 소스 코드들은 구현 파일에 담기고
구현 파일들간의 조율을 위한 코드들은 헤더 파일에 나뉘어 담긴다.

#include 지시문
18_1.cpp
cpp를 구현 파일이라고 생각하면 된다. 헤더파일은 h의 확장자를 갖는 것이 일반적.
18_2.cpp, 18_2.h
헤더 파일을 새롭게 생성했다. 일부를 헤더 파일로 옮겼다.
#include지시문의 역할은 특정 파일의 내용을 소스 코드 안으로 불러들이는 것이다.
지시문이 위치한 곳에 헤더파일의 내용을 복사한 것 같은 기능을 한다.

기존의 소스를 여러 파일로 나누어 보자.
무작정 나누기
18_3.cpp
18_4.cpp 18_4_2.cpp
다른 파일에 있는 함수는 호출할 수가 없다. 

다른 파일에 있는 함수 사용하기.
그래서 다음과 같은 작업이 필요하다.
18_5.h 18_5.cpp 18_5_2.cpp
헤더 파일을 새롭게 추가했고 원형을 포함한다. 그리고 #include를 사용해 헤더 파일을 포함.
헤더파일은 main()함수에게 지도와 같은 역할.
정리해보면
1)공유될 함수가 있는 구현 파일의 이름을 따서, 헤더 파일을 만든다.
2)이 헤더 파일에 공유될 함수의 원형을 적어준다.
3)공유될 함수를 호출할 구현 파일에서는 이 헤더 파일을 포함한다.

다른 파일에 있는 함수 사용하기 - 실전
우선 헤더파일 없이 나눠보자.
18_6
example.cpp A.cpp B.cpp
1)첫번째로 "공유될 함수가 있는 구현 파일의 이름을 따서, 헤더 파일을 만든다"
18_7
example.cpp A.cpp B.cpp A.h B.h
2)두번째로 "이 헤더 파일에 공유될 함수의 원형을 적어준다"
3)세번째로 "공유될 함수를 호출할 구현 파일에서는 이 헤더 파일을 포함한다"
main()은 A1(), B1()을 호출하고 있으므로 포함할 필요가 있다.
A.cpp에서 A2()함수에서 B1(),B2()를 호출하고 있기 때문에 헤더파일을 포함시킬 필요가 있다.
18_8
example.cpp A.cpp
A2()를 찾을 수 없어 오류를 발생. A1()에서 A2()를 호출하는데, A2()가 A1()의 뒤에 있다.
18_9
A.cpp
사실 A2()의 원형을 적어주는 대신에 그냥 A.h를 포함하면 된다. A.h에 원형이 있기 때문에.
18_10
A.cpp
4)마지막 규칙은 "구현 파일에 자기 자신에 대한 헤더 파일을 포함하게 만든다."
같은 구현 파일 안에 있는 함수끼리 호출하지 않는 경우는 거의 없다.
18_11
B.cpp

다른 파일에 있는 구조체 사용하기
여러 파일에 나누어 사용하는 방법이 함수와 조금 다르다.
18_12.cpp
Distance()함수를 별도의 파일로 분리하자.
18_13
Example1.cpp Example2.cpp
Distance()함수를 공유할 수 있게 조치를 취해보자.
18_14
Example1.cpp Example2.h Example2.cpp
물론 헤더파일을 포함하지 않아도 되지만 편리하기 때문에 선언해줌.
여기까지는 Point를 모르기 때문에 오류가 발생한다.
다시 헤더파일을 이용해보자.
18_15
Point.h Example1.cpp Example2.cpp
Point구조체의 정의부분을 별도의 헤더 파일로 옮겨놓고, 필요한 구현 파일마다 헤더파일을 포함.
1)구조체의 이름을 따서 새로운 헤더 파일을 만든다.
2)이 헤더 파일에 구조체의 정의 부분을 위치시킨다.
3)구조체를 사용하는 구현 파일마다 이 헤더 파일을 포함시킨다.

헤더 파일의 포함 순서가 중요하다.
18_16
Example2.cpp
오류 발생 한다.
틀린것을 확인해보려면 헤더파일의 정보들을 직접 넣어보자.
18_17
18_18
Example2.cpp
#include지시문이 하는 일은 정말 단순하게도 헤더 파일의 내용을 불러오는 것 밖에 없다.

헤더 파일이 두 번 포함되는 것 막기
소스 파일이 아주 많아지면 파일 간의 포함 관계가 복잡해질 수 있다.
18_19
Point.h Example3.cpp
Point구조체를 두 번 정의되기 때문에 오류가 발생.
18_20
Point.h
앞뒤로 적어줘서 중복을 방지했다.
1)헤더 파일의 이름을 따서 심볼을 만든다(POINT_H)
2)헤더 파일의 제일 앞에 이 심볼을 사용해서 #ifndef, #define 명령을 추가한다.
3)헤더 파일의 제일 끝에 #endif를 추가한다.
중요한 건 헤더 파일마다 중복하지 않는 심볼을 사용해야 한다.
사실 모든 헤더 파일에 이와 같은 작업을 미리 해주는 것이 좋다.
실제로 iostream같은 모든 표준 라이브러리의 헤더 파일에도 이와 같은 처리.

표준 라이브러리의 헤더 파일
표준 라이브러리란 C++에서 기본적으로 제공하는 함수, 구조체, 클래스 등을 의미한다.
표준 라이브러리의 경우에는 <>를 사용하고, 손수 만든 파일에 대해서는 ""를 사용한다.
두 가지의 차이점은 헤더 파일을 찾는 위치에 있다.
<>를 사용하는 경우는 표준 라이브러리의 헤더 파일이 위치한 폴도에서 파일을 찾는다.
""를 사용하는 경우는 현재 소스 파일이 있는 위치에서 찾는다.

#include와 관련된 호환성 문제
조금 오래된 컴파일러의 경우에는 새롭게 변경된 C++의 기능을 반영하지 못하고 있을 수 있다.
예로 #include <iostream>을 오류발생한다면 #include <iostream.h>로 바꿔봐야한다.
만약 c가 붙어있는 #include <cmath>는 #include <math.h>로 바꿔봐야한다.

*/