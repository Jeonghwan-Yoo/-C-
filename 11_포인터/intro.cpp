/*
01 포인터의 기본
왜 포인터를 사용해야 할까
포인터는 변수의 타입 중에 하나다. 포인터 타입의 변수를 줄여서 포인터.
포인터는 손가락이고 실체가 변수가 된다.
실제로 포인터는 다른 변수의 위치를 가리키는 변수다.
도서관의 책 위치, 동사무소 집 위치, 참조문구의 페이지 위치 등

메모리와 변수
메모리는 정보를 저장하기 위한 하드웨어.
변수는 메모리에 위치하며, 메모리는 한 바이트 단위로 방을 가지고 있다.
포인터는 변수의 위치를 가리키는 것을 하는데, 변수의 위치를 알아낼 수 있어야 한다.
변수의 위치를 절대적인 기준으로 나타내기 위해서 우리는 '주소'라는 개념을 도입
메모리의 각 방은 한 바이트를 기준으로 나누어져 있는데, 이 방 하나마다 주소가 부여되어 있다.
여러 개의 방에 걸쳐서 자리잡은 정보의 경우에는 첫번째 방의 주소가 그 위치가 된다.
11_1.cpp
변수의 위치, 주소를 구하는 방법은 변의 이름 앞에 &를 붙여주는 것이다.
주소들의 값이 그다지 차이가 나지 않는데, 거의 동시에 정의한 변수이기 때문.

포인터 변수에 주소를 보관하기
포인터 변수 역시 변수다. 그곳에 정보를 담을 수 있다.
그러나, 오직 변수의 주소만을 담을 수 있다.
예로 int a가 있다고하면, 포인터 변수 p에 a의 주소가 저장되있다고하자.
그러면 "포인터 p가 변수 a를 가리키고 있다"라고 할 수 있다.
11_2.cpp


포인터의 종류
int* 타입의 포인터 변수는 int 타입의 변수만 가리킬 수 있다.
char c;
int* p = &c; 는 오류를 발생한다.
char * p = &c; 로 고쳐줘야 한다.
즉, '포인터로 가리키고 싶은 타입'을 적어주소 *를 붙여주면 된다.
11_3.cpp

포인터 변수의 주소와 초기화
포인터 변수도 변수다. 주소를 담을 수 있는 변수인 것이다.
포인터 변수에도 주소가 존재한다.
포인터 변수도 정의와 동시에 초기화할 수 있다. 안하면 쓰레기 값을 갖는다.
int* p = &a;

세가지 모두 같은 의미
int* p;
int *p;
int * p;

왜 포인터는 하나의 타입밖에 가리킬 수 없을까
메모리에는 변수의 값만 저장할 뿐 변수의 타입은 저장하지 않기 때문이다.
주소값을 받은 다음 타입을 몰라서 할 수가 없다.

포인터 변수의 크기
모든 포인터 변수의 크기는 동일하다.
포인터 변수에 보관되는 값은 주소 값이기 때문이다.
32비트 윈도우즈라면 4바이트고 16비트면 2바이트가 된다.

void 포인터
void* p;
void 타입의 변수를 가리키는 포인터가 된다.
하지만 void 타입의 변수는 존재 하지 않습니다.
void 타입이란 타입이 없음을 의미하기 때문이다.
void 포인터는 모든 타입을 가리킬 수 있는 포인터다.
int, char, double 등 모두 가리킬 수 있다.
하지만 void포인터를 사용해서 할 수 있는 것은 없다.
변수가 어떤 타입인지에 관한 힌트가 없기 때문이다.
void 포인터는 흔히 주소를 저장하는 용도로 사용한다.
타입에 상관없이 주소를 보관하는 용도로 사용한다.
보관된 주소를 사용하기 위해서는 타입이 있는 포인터로 형변환 시킬 필요가 있다.
11_4.cpp
형변환은 "그곳에 int 타입의 값이 있다"라는 정보를 추가해주는 셈.

주소를 사용해서 정보에 접근하기
11_5.cpp
*p라는 수식은 'p가 가리키는 변수'라는 뜻으로 해석된다.

*의 의미
*은 포인터 타입을 만들기 위한 것. (처음만)
그 외의 문장에서는 포인터가 가리키는 곳의 값을 의미(Dereferencing)하는 것.

포인터의 동작 방식을 확인하자
강제적으로 char*타입의 포인터가 int타입의 변수를 가리키게 만든다.
11_6.cpp
*pc는 "pc가 가리키는 곳에 char 타입의 값이 있는데 그걸 가져와" 그래서 1바이트만 가져옴.
저장은 0x78 0x56 0x34 0x12순으로 저장되어 있기 때문에 78을 가져온다.

빅 엔디안과 리틀 엔디안
Big-Endian과 Little-Endian은 2바이트 이상의 크기를 가진 변수가 메모리에 자리잡는 방식.
int타입의 변수가 메모리에 자리잡을 때 거꾸로 자리를 잡는다. 이런 경우를 리틀 엔디안.
PC에 주로 사용하는 인텔 CPU는 이 방식을 사용한다.
빅 엔디안 방식은 순서대로 자리를 잡는데 대부분 RISK 기반 CPU들.

NULL
int *p;
*p = 128; 에서 문제는 p를 초기화하지 않은 상태에서 사용했기 때문이다.
p를 초기화하지 않은 상태에서는 쓰레기 값을 가진다.
이 말은 p가 어디를 가리키고 있는지 모른다는 것.
시스템에 접근하고 있으면 심각한 오동작을 일으킬 수 있다.
1)포인터 변수는 항상 0으로 초기화해야 한다.
2)포인터 변수를 사용하기 전에는 0이 아닌지 비교해야 한다.
주소 0번지에 위치할 수 있는 변수는 없기 때문에 '아무것도 가리키지 않음'의 의미로 사용.
11_7.cpp
p의 값을 매번 검사하는 것은 시간이 걸리지만 잘못된 포인터의 사용으로 인한 피해는 더 무서움.
100% 안전을 확신하면 비교해줄 필요는 없다.
아무것도 가리키지 않음을 나타내는 값으로 0대신에 NULL을 사용하는 경우가 많다.
NULL이란 0의 값을 가진 변수이며 가리키는 것이 없다. (void*)0
11_8.cpp

02 포인터와 Const
기본 타입과 const
const는 변수의 값을 변경할 수 없게 만드는 속성.
변수를 정의할 때 const키워드를 같이 적어주면, 그 변수의 값은 바뀔 수 없다.
변수인데 상수같은 변수가 되는 것.
11_9.cpp
const를 사용해서 변수를 정의할 때는 반드시 초기화해줘야 한다는 점을 잊지 말자.
1)처음 정의할 때부터 const로 정의하는 경우
2)원래는 const가 아니었지만 다른 곳에 넘겨줄 때만 잠깐 const인 척하는 경우.
1)은 여러 곳에 쓰이는 상수를 대신해서 사용하는 경우.
11_10.cpp
개수가 200개로 변경되면 size만 100에서 200으로 변경해주면 된다.
2)는 다른 곳에 변수의 값을 제공하기는하지만 읽기만 할 수 있을 뿐, 바꾸지 못하게 할 때(함수)

포인터와 const의 사용
포인터 변수를 정의할 때는 const를 최대 2개까지 포함할 수 있다.
포인터 변수는 2개의 정보와 관련이 있기 때문.
1)포인터 변수 자체에 보관한 정보. (p)
2)포인터가 가리키는 변수에 보관된 정보. (*p)
두 가지 정보에 대해서 const여부를 설정할 수 있다.
11_11
int i1 = 10;
int i2 = 20;
int* p = &i1;
p = &i2;
*p = 30;
위에는 문제없다.
11_12
int i1 = 10;
int i2 = 20;
const int* p = &i1;
p = &i2;
*p = 30; //FAIL
"p가 가리키는 변수는 const int 타입이다"
즉, p가 가리키는 변수의 값을 바꾸는 것을 허용하지 않는다.
11_13
int i1 = 10;
int i2 = 20;
int* const p = &i1;
p = &i2; //FAIL
*p = 30;
"int타입을 가리키는 p는 const 속성을 같는다"
p의 값을 바꾸는 행위를 허용하지 않는다.
11_14
int i1 = 10;
int i2 = 20;
const int* const p = &i1;
p = &i2; //FAIL
*p = 30; //FAIL
포인터 p뿐만 아니라 p가 가리키는 변수까지도 const라는 의미.

const의 의미를 외우는 법.
const의 다음에 오는 것을 상수화 시켜버린다고 생각하면 된다.
'const int* p'는 const 다음에 int가 오므로 'int 타입의 값, 즉 포인터가 가리키는 값이 const'
'int* const p'는 const 다음에 p가 오므로 'p자체가 const'가 된다.

*/