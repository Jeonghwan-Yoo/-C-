/*
01 클래스와 객체의 기본
클래스와 객체는 객체지향 프로그래밍의 가장 기본적인 도구.

클래스의 정의
붕어빵 틀을 만든다고 생각

Point 클래스
Point구조체를 클래스로.
21_1.cpp

구조체와 다른점
class라는 키워드를 사용해서 정의한다.
public과 같은 접근 제어와 관련한 키워드를 사용한다.
멤버 함수 역시 정의할 수 있다.

구조체에서 멤버라고 불리던 것이 클래스에서는 멤버 변수.
멤버 함수는 클래스의 멤버로써 존재하는 함수.
접근 제어는 클래스의 외부에서 멤버에 접근할 수 있는지를 설정하는 것.

객체의 생성과 사용
아주 간단한 객체의 생성과 사용
21_2.cpp
Print()함수안에 x,y는 자기 자신의 멤버 변수는 x,y를 의미한다.
멤버 함수 안에서는 그냥 x,y라고 해도 된다.

멤버 함수
일반 함수와 멤버 함수의 차이점
멤버 함수는 기본적으로 일반 함수와 같다.
디폴트나 오버로드할 수 있다.
1)멤버 함수르 호출하기 위해서는 객체의 이름을 명시해주어야 한다.
2)멤버 함수 안에서는 객체의 이름을 명시하지 않고 멤버 변수에 접근할 수 있다.
이미 멤버 함수를 호출하면서 객체의 이름을 명시해주었기 때문에.
3)멤버 함수 안에서는 외부에서 접근을 거부한 멤버에도 접근할 수 있다.
기밀은 어디까지나 외부 사람에 대한 것. 같은 클래스이기 때문.

멤버 함수의 위치
멤버 함수를 클래스 밖에서 정의할 수도 있다. 간결하게 유지 가능.
21_3.cpp
클래스 밖에서 정의하려면
1)클래스 정의 안에서는 멤버 함수의 원형만 남겨둔다.
2)클래스 정의 밖에서는 범위 지정 연산자(::)를 사용해서 함수를 정의한다.
Scope Resolution Operator는 일반 함수를 정의하는 것과 혼동하지 않기 위해서.
기본적으로 클래스의 밖에서 정의해주는 것을 원칙으로하면 좋다.
아주 짧으면 안에서 정의해도 된다.

멤버 함수 안에서의 이름 충돌
21_4.cpp
'함수 안에서 정의한 변수 x'를 의미한다.
멤버 함수 안에서 변수를 정의할 때는 주의할 필요가 있다.
가능하면 멤버 변수와 같은 이름의 변수를 만들지 않는 것이 좋다.
그렇기 때문에 매개변수의 이름도 멤버 변수와 다르게 지어야 한다.
void Point::Print(int x){
	cout << "(" << x << ", " << y << ")\n";
} 에서도 x는 매개변수의 x이다.

멤버 변수의 이름 짓기
일반 변수와 충돌을 피하기 위해 특별하게 짓는 방법.
모든 멤버 변수의 이름앞에 _(Underscore)나 m_등의 접두사를 붙이는 방법.
class Point{
public:
	int _x, _y;
	Print(int x);
};
void Point::Print(int x){
	cout << "(" << _x << ", " << _y << ")\n";
}
이렇게하면 충돌도 발생하지 않고 소스코드를 읽기도 쉽다.

객체를 사용한 초기화와 대입
기본적으로 구조체와 같다.
모든 멤버 변수의 값을 1:1로 대입하는 방식.
멤버 함수는 고려할 필요가 없다.
21_5.cpp
1:1로 복사한다. 하지만 초기화(Initialization)과 대입(Substitution)을 구분해야 한다.
객체를 정의하면서 '초기화', 이미 생성한 객체에 '대입'하는 것은 서로 다른 연산.

생성자와 소멸자
Constructor와 Destructor는 특별한 기능을 가진 멤버 함수이다.
생성자는 객체를 생성할 때 자동적으로 호출되는 함수고,
소멸자는 객체가 소멸될 때 자동으로 호출되는 함수이다.

생성자와 소멸자는 어디에 사용할까
생성자에서 하는 일은 객체가 제대로 동작할 수 있게 '준비'하는 일. 
정수형 변수에 0의 값을 넣어주거나 포인터 변수에 NULL의 값을 넣어주는 것.
동적으로 할당한 메모리를 사용하려면 생성자에서 메모리를 할당하기에 좋다.
소멸자에서는 '정리'에 해당하는 작업을 해주면 된다.
할당했던 메모리를 해제하거나 파일을 닫아주거나.
즉, 생성자에서는 '준비'를 하고, 소멸자에서는 '정리'를 한다.

생성자의 사용
한 클래스에는 생성자가 없을 수도 있고 1개 이상 존재할 수도 있다.
디폴트 생성자
Point클래스에 디폴트 생성자를 추가했다.
21_6.cpp
1)생성자는 클래스와 동일한 이름
2)생성자는 반환 값이 없다.
객체가 생성할 때 자동으로 호출된다는 점을 제외하고는 멤버 함수와 다를 것이 없다.
생성자가 존재하지 않았다면 매번 객체를 생성할 때마다 따로 초기화를 해주어야 했을 것이다.
아무런 인자가 없는 생성자를 디폴트 생성자라고 부르는데 가장 기본적인 생성자.

인자가 있는 생성자
21_7.cpp
인자를 하나 이상 가지고 있는 생성자.
생성자는 객체를 생성할 때 호출되기 때문에 인자를 넘겨주는 것도 객체를 생성할 떄 해주어야 한다.
인자를 가진 생성자를 여러 개 만드는 것도 가능한데 생성자들의 시그니처는 모두 달라야한다.
오버로드된 생성자가 여러개.
인자가 있는 경우에는 각 객체마다 다른값으로 초기화하는 것이 훨씬 수월해진다.

복사 생성자
Copy Consturctor는 다른 객체로부터 값을 복사해서 초기화하는데 사용한다.
21_8.cpp
복사 생성자는 자신과 동일한 타입의 객체에 대한 레퍼런스를 인자로 받는 생성자이다.
Point(Point& pt);
Point(const Point& pt);
둘 다 복사 생성자이지만 const쓰는 것을 권장한다.
복사생성자는 객체를 사용해서 초기화하는 경우. 디폴트생성자는 호출되지 않는다.
Point pt3(pt1);
이렇게도 복사 생성자가 호출된다.
초기화의 문법을 사용하건 생성자의 호출의 문법을 사용하건 완전히 동일.
'대입'하는 경우에는 복사 생성자가 호출되지않고 오직 '초기화'할 때만 호출.
사실 복사생성자를 만들지 않았을 때도 초기화는 잘 동작했다.
그런데도 필요한 이유는 1:1로 복사하는 것 말고 다른 방식으로 복사하고 싶은 경우가 있다.
객체를 사용한 초기화는 기본적으로 멤버 변수를 1:1로 복사해준다.
이것이 마음에 들지 않는다면 복사 생성자를 원하는 방식으로 만들면 된다.

문자열의 포인터만 복사하는 경우에는 같은 문자열을 공유하게 되는데 이런 방식의 복사를 얕은 복사.
새로운 문자열을 하나 만들어서 복사해주는 경우는 서로 다른 문자열을 갖는데, 깊은 복사라고 한다.

반드시 생성자가 있어야 하는 경우
멤버 변수 중에 const속성을 가진 것이 있거나 레퍼런스 타입이 있다면 반드시 필요하다.
const속성을 가진 변수와 레퍼런스 변수는 '반드시 초기화되어야 한다'는 공통점.
정의하고 나면 변경할 수 없다.
한번 객체를 생성하자마자 멤버 변수들을 초기화해보자.
21_9.cpp
사용할 수 있는 적절한 기본 생성자가 없어서 오류를 발생시킨다.
생성자에서 초기화해보자
21_10.cpp
초기화하는데 실패했다.
생성자의 코드보다도 이전에 초기화해줄 수 있는 '어딘가'를 필요로 한다는 뜻.
생성자의 초기화 리스트가 바로 그 역할을 한다.
21_11.cpp
생성자의 초기화 리스트를 사용하면 const나 레퍼런스 멤버 변수를 초기화할 수 있었다.
즉, 반드시 초기화 해야하는 멤버 변수들은 생성자의 초기화 리스트를 사용해서 초기화한다.
NeedConstructor::NeedConstructor() : maxCount(100), ref(sample) {
	sample = 200;
}
언뜻보기에도 중괄호 안에 있는 소스코드들 보다도 먼저 실행한다는 느낌을 준다.
콜론(:)을 찍고 멤버 변수의 이름을 적고 이어지는 괄호 안에 초기 값을 넣어주면 된다.
생정자의 초기화 리스트는 디폴트 생성자에서만 사용할 수 있는 것은 아니다.
인자가 있는 생성자에서도 가능하다.
21_12.cpp
count와 number를 사용해 멤버 변수들을 초기화해주었다.
객체를 생성하면서 인자를 넘겨주게 되면, 이 인자를 사용해서 멤버 변수를 초기화한다.

생성자를 사용해서 임시 객체 만들기
알아두면 편리한 정도
어떤 점의 값을 Point객체가 아닌 int타입으로 가지고 있다고 한 경우에 Point객체로 새로만듦
21_13.cpp
Point객체를 생성하지 않고 바로 Area()함수를 호출하는 방법.
21_14
Point temp(x, y); Area(temp); -> Area(Point(x, y));
이렇게 하면 Point타입의 임시 객체가 생성되고, 그 객체는 초기화 된다.
그리고 나서 임시 객체를 인자로 전달하는 것.
실행이 끝나면 자동적으로 소멸한다.
즉, 함수를 호출하기 위해 임시적으로 객체가 필요한 경우 생성자를 사용해 임시객체를 만들 수 있다.

소멸자의 사용
객체가 소멸할 때 자동적으로 호출되는 함수다.
생성자의 이름 앞에 틸드(~)를 붙인 형태를 갖는다.
소멸자는 클래스에 오직 하나만 존재할 수 있다.
여러 개의 정수를 입력 받은 후에 역순으로 화면에 출력
21_15.cpp
DynamicArray클래스는 내부적으로 동적 메모리 할당을 사용한다.
생성자에서는 메모리를 동적으로 할당하고 그 주소를 arr 멤버 변수에 보관해둔다.
main()함수가 끝나면 da객체가 자동적으로 소멸하게 된다.
함수 안에서 정의한 변수는 그 함수의 종료와 동시에 소멸된다.
객체가 소멸하면서 자동적으로 소멸자가 호출되고 소멸자안에서 arr이 가리키는 메모리를 해제.
만약에 소멸자라는 것이 없었다면 사용했을 때마다 메모리를 해제 했을 것이다.

접근 제어(Access Control)
왜 접근 제어가 필요할까
클래스에서 말하는 접근제어는 어떤 멤버를 외부에 보이게 할 것인지 지정하는 작업.
정보 은닉을 달성할 수 있는 수단.
어떤 멤버가 약속된 것이라면 외부에서 볼 수 있게 지정해주어야 한다.
어떤 일이 있어도 이 약속이 변하면 안된다. 어기게 되면 문제가 발생하기 때문.
약속되지 않은 것이라면 외부에서 볼 수 없게 막아야 한다.
그렇지 않으면 실수로 다른 클래스가 그 멤버를 사용할 수 있기 때문.

생성자와 소멸자의 접근 권한
생성자와 소멸자도 접근 권한을 지정할 수 있는데, public으로 하는 것이 일반적이다.
private로 지정하면, main()함수에서 Point객체를 생성할 수 없다. 생성자에 접근할 수 없어서.

접근 권한 설정하기
public:외부에서의 접근을 허용한다.
protected, private:외부에서 접근할 수 없다. 상속에선 다르다.
21_16.cpp
키워드 아래쪽에 놓인 멤버들은 해당 키워드가 의미하는 접근 권한을 갖게 된다.
얼마든지 여러 번 등장할 수 있다.
main()함수는 '외부'가 된다.
클래스에게 있어서 '내부'는 멤버 함수밖에 없다.
어디까지나 외부에서 접근할 수 있느냐를 설정한것이다.
즉, 클래스의 내부인 멤버 함수에서는 접근 권한에 상관없이 모든 멤버에 접근할 수 있다.
21_17.cpp
멤버함수에서는 접근권한에 상관없이 모든 멤버에 접근할 수 있었다. 클래스의 내부이기 때문에.
main()함수에서는 AccessAllMember()함수를 호출할 수 있었다.
private로 지정한 멤버에 직접 접근할 수는 없지만 public으로 지정한 멤버 함수를 통해
간접적으로 접근할 수는 있다.

구조체와 접근 권한
구조체는 클래스가 할 수 있는 모든 일을 할 수 있지만 C와 호환성때문에 그렇게 안한다.
접근 권한과 관련된 키워드를 작성하지 않으면 클래스는 기본적으로 private 구조체는 public.
클래스는 private 접근 권한이 디폴트지만 구조체는 public 접근 권한이 디폴트.

접근자
클래스에서 모든 멤버 변수는 protected나 private로 만드는 것이 좋다.
약속된 부분(인터페이스)에 멤버 벼수를 놓지 말라는 뜻이다.
멤버 함수와는 달리 멤버 변수를 공개하게 되면 많은 문제가 발생할 수 있다.
올바르지 않은 값을 대입하거나 도중에 갑자기 값이 바뀔수도.
그래서 직접 멤버 변수를 노출하는 대신에 접근자를 사용해서 간접적으로 멤버 변수를 노출하는 방법.
접근자는 단순히 public접근 권한을 가진 멤버 함수로 외부에서 멤버 변수에 접근하는 것을
도와주는 혹은 감시하는 역할을 한다.
21_18.cpp
컴퓨터의 입장에서도 이 함수들은 그냥 멤버 함수일 뿐이다.
private로 지정한 멤버 변수들에 접근할 수 있게 도와주는 것이 전부다.
접근자를 사용하면 범위를 벗어난 잘못된 값을 대입하는 것을 막을 수 있다.
21_19.cpp
하지만 생성자를 통해서 멤버 변수의 값을 초기화해주면 잘못된 값이 대입될 수도 있다.
21_20
Point pt(-50, 200);
그렇다고 생성자를 고치는 것은 매우 잘못된 것이다.
21_21
생성자를 고친다고 하면
if (initialX < 0)
	x = 0;
else if (initialX > 100)
	x = 100;
else
	x = initialX;
이런식으로 고치면 작동을 잘하는 것처럼 보인다.
범위가 수정되고 한쪽만 범위를 수정하면 나중에 소스코드의 중복으로 인해 문제가생긴다.
그래서 생성자를 위와 같이 고치는 대신에 만들어 둔 접근자를 통해 값이 대입되게 하면.
21_22
Point::Point(int initialX, int initialY){
	SetX(initialX);
	SetY(initialY);
}
그럼 생성자를 초기화하는 경우에도 유효한 범위 안의 값만이 대입된다.
프로그램을 잘 짜기 위해서는
1)모든 경우를 감시해야 한다.
2)그 모든 경우에 동일한 코드를 사용하게 만들어야 한다.

정적 멤버(Static Members)
정적 멤버의 기본
정적 멤버는 모든 객체가 공유하는 멤버다.
지금껏 배워온 멤버 변수와 함수들은 객체마다 존재했었고 자신의 멤버를 사용했다.
하지만 정적 멤버 변수와 정적 멤버 함수는 클래스에 오직 하나만 존재하기 때문에
모든 객체들은 하나의 정적 멤버를 같이 사용하게 된다.
즉, 모든 객체는 동일한 정적멤버를 공유한다.
그래서 클래스 자체에 관련된 정보나 전체 객체와 관련된 정보를 보관하고 다루는데 유용.
예로 지금까지 생성한 전체 객체의 수를 관리하거나 공통적으로 참조해야 하는 정보.
청소도구, 출입구 등은 학생들이 공유해야 한다.

정적 멤버를 사용한 객체 수 세기
21_23.cpp
main()함수에서 하는 일은 Student 객체를 생성하거나 소멸되게 한 다음
그 사이사이에 객체의 수를 출력하는 것이 전부.
정적 멤버는 객체의 소유가 아니라 클래스의 소유라는 점.
보통의 멤버를 외부에서 접근하기 위해서는 std1.name처럼 객체의 이름을 사용해야하지만
정적 멤버를 외부에서 접근하기 위해서는 Student::PrintStdCount처럼 클래스의 이름사용.
정적 멤버는 클래스의 소유라는 관점에서 매우 타당한 문법.
중요한 것은 아무런 객체가 만들어지지 않은 상태에서도 정적 멤버는 사용이 가능.

정적 멤버 함수에서는 일반 멤버에 접근할 수 없다.
이와 같은 코드는 불가능.
//정적 멤버함수
void Student::PrintStdCount(){
	name = "student1" //실패
	sNo = 33333; //실패
	cout << "Student 객체 수 = " << student_count << "\n";
}
도대체 누구의 name이나 sNo를 말하는지 알 수 없기 때문이다.
이것은 가능
//정적 멤버함수
void Student::PrintStdCount(){
	Student std("",0);
	std.name = "stduent1"; //성공
	std.sNo = 33333; //성공
	cout << "Student 객체 수 = " << student_count << "\n";
}
멤버기 때문에 만약 멤버 변수가 private로 설정되있다 하더라도 접근 가능.

헤더 파일과 구현 파일
지금까지 있는 파일
21_24
21_19.cpp
나누어 담기
21_25
Point.h Point.cpp Example.cpp
Point.h는 클래스의 정의.
Point.cpp는 멤버 함수들.
Example.cpp는 클래스의 사용.
1)소스 코드가 간결해져서 읽기에 편하다
2)관련된 내용끼리 모여있으므로 필요한 부분을 찾아보기 쉽다.
3)소스 코드의 관리와 재사용이 편하다.

헤더파일:클래스의 정의, 인라인 멤버 함수
구현파일:멤버 함수의 정의, 정적 멤버 함수의 정의, 정적 멤버 변수의 정의

02 클래스와 객체 자세히 살펴보기
멤버 함수
인라인 함수
Inline Function은 함수의 속성이다. 멤버가 아닌 함수도 인라인이 될 수 있다.

왜 인라인 함수를 사용할까
함수를 호출하는 대신에 함수의 내용을 그대로 옮겨 놓는 것.
inline 키워드가 함수를 인라인으로 만들어준다.
21_26.cpp
인라인 함수라는 사실을 망각해보면 main()함수에서 Func()를 호출하면 실행의 흐름이
Func()로 이동한다. Func()을 종료하면 다시 main()으로 실행의 흐름을 이동하고 종료.
하지만 인라인인 경우에 컴퓨터는 이렇게 인식한다.
21_27.cpp
Func()함수의 내용을 고스란히 옮겨 놓는것이다.
함수를 호출하는 대신에 함수의 내용을 붙여넣는다.
일반적인 함수라면 실행의 흐름이 다른 함수로 넘어갔다가 돌아오는 작업이나,
인자를 복사하는 과정에서 많은 부하(Overhead)가 발생한다.
인라인 함수를 사용하면 이런 작업들이 불필요하게 되므로 시간을 벌 수 있는 것.
꼭, 함수의 내용이 몇 줄 정도로 아주 짧은 경우에만 인라인 함수로 만들자.
하지만 우리가 인라인 함수로 만들고 싶다고해서 항상 인라인 함수가 되는 건 아니다.
그냥 우리는 "될 수 있으면 이 함수를 인라인으로 만들어줘"라고 할 뿐
실질적으로는 컴퓨터가 결정한다.
일반적으로 재귀 함수인 경우나 누군가가 그 함수의 주소를 얻어서 사용하면 불가능.

인라인 함수를 만드는 법
1)클래스의 내부에 정의한 멤버 함수들은 모두 자동으로 인라인 함수가 된다.
2)클래스의 외부에 정의한 멤버 함수는 함수의 정의 앞에 inline키워드를 추가한다.
Point클래스에서 인라인으로 고칠것들을 고쳐보자.
21_28
Point.h
SetX(), SetY(), GetX(), GetY()는 자동적으로 인라인 함수가 되는 경우에 속한다.
21_29 우리가 보는 코드
Point pt;
pt.SetX(100);
pt.SetY(200);
21_30 컴퓨터가 보는 코드
Point pt;
//pt.SetX(100);
int temp1 = 100;
if (temp1 < 0) pt.x = 0;
else if (temp1 > 100) pt.x = 100;
else pt.x = temp1;
//pt.SetY(200);
int temp2 = 100;
if (temp2 < 0) pt.y = 0;
else if (temp2 > 100) pt.y = 100;
else pt.y = temp2;
클래스의 내부에서 정의하는 방법은 특별히 해줄게 없다.
외부에서 정의한 멤버 함수를 인라인으로 만들어 보자.
21_31
Point.h
함수의 정의 앞쪽에 inline키워드를 붙여주는 것이 끝이다.

인라인 함수는 반드시 헤더 파일에 있어야 한다.
1)인라인 함수가 클래스의 정의 내부에 있는 경우
->어차피 클랫의 정의는 헤더 파일에 위치하므로 특별히 신경쓸게 없다.
2)인라인 함수가 클래스의 정의 외부에 있는 경우
->함수의 정의를 헤더 파일에 위치시켜야 한다.
다음은 문제가 발생하는 코드
21_32
Point.h Point.cpp Example.cpp
SetX()와 SetY()를 찾을 수 없다는 오류가 발생할 수 있다.
다시 인라인 함수를 헤더 파일로 옮기자.
21_33
Point.h
인라인 함수를 헤더 파일에 두자!
멤버가 아닌 함수가 인라인인 경우에도 그 함수는 헤더파일에 위치해야 한다.

인라인 함수를 헤더 파일에 넣지 않아도 실행은 되던걸요??
소스 코드를 여러 개의 파일로 나눈 경우를 가정했기 때문.
하나의 파일에 모든 소스 코드를 다 넣어둔 경우라면 구현 파일에 있어도 잘 작동.
이렇게 여러 파일로 분리한 경우에도 인라인 함수가 구현 파일에 있는것이 허용되는 경우.
컴퓨터가 나름대로의 규칙에 의해서 그냥 보통 함수로 만들어버린 경우.
호출방식이 아닌 매크로함수 같이 복붙을 하는데 선언문과 정의부분이 따로 있어서 문제.

인라인 함수의 단점
프로그램의 크기가 커진다는 점.
그렇기 때문에 긴 함수를 인라인으로 만들지 않는 것이 좋다.
오히려 프로그램의 수행 속도가 떨어질 수 있다.
메모리에 올라갔다 내려갔다를 더욱 반복되기 때문.

Const함수
왜 Const함수를 사용할까
멤버 변수의 값을 변경하지 않는 멤버 함수만 Const함수로 만들 수 있다.
멤버 함수 안에 멤버 변수의 값을 변경하는 코드가 없다는 뜻.
1)다른 개발자가 멤버 변수의 값을 변경하지 않는 함수라는 것을 알게해줌.
2)실수로 멤버 변수의 값을 바꾸려고 하면, 컴퓨터가 오류 메시지.
3)Const객체를 사용해서 이 함수를 호출할 수 있다.
Const객체란
const Point pt(100, 100);
기본 타입의 변수가 Const라면 그 변수의 값을 바꿀 수가 없었는데,
객체가 Const인 경우에는 해당 객체의 멤버 변수의 값을 바꿀 수가 없다.
Const객체의 멤버 변수에 접근해서 값을 바꾸려고 하면 오류메시지.
멤버 변수의 값을 바꾸는 멤버 함수를 호출하는 경우에도 오류메시지.
하지만 멤버 변수의 값을 바꾸지 않는 Const 멤버 함수를 호출하는 것은 허용.
const객체는 const 멤버 함수만 호출할 수 있다.
Class CellPhont{
public:
	int bell_mode;
	void Call(int quick_num);
	void ShowRecentCall() const;
};
void main(){
	const CellPhone myPhone;
	myPhone.bell_mode = 3; //오류
	myPhone.Call(1); //오류
	myPhone.ShowRecentCall(); //ok
}

Const함수의 사용
멤버 변수의 값을 바꾸지 않는 멤버 함수라고 해서 자동으로 Const가 되는 것은 아니다.
직접 Const로 만들어주어야 하는데 가능한 모든 멤버 함수를 Const로 만들어주는 것이 좋다.
함수를 모두 Const로 만들지 않은 경우.
21_34
Point.h Point.cpp 21_34.cpp
함수 안쪽에서 객체의 멤버 변수의 값을 변경하지 않는 경우
객체를 인자로 넘길 때는 const 타입의 레퍼런스를 넘기는 것 일반적.
const객체를 사용해서 const가 아닌 멤버 변수를 호출하는 것은 불가능.
컴퓨터는 const가 아닌 멤버 함수는 멤버 변수의 값을 변경한다고 생각.
즉, 가능한 모든 멤버 함수를 const로 만들자.

멤버 함수에 대한 포인터
기존에 멤버가 아닌 함수에 대한 포인터를 만들던 방식으론 멤버 함수를 가리킬 수 없다.
21_35 멤버 함수에 대한 포인터
21_35.cpp
멤버 함수에 대한 포인터 타입을 정의하는 문법
멤버함수에 대한 포인터는 어느 한 클래스의 멤버 함수들만을 가리킬 수 있다.
typedef void (Point::*FP2)(int);
typedef로 타입 이름을 재정의하는데, Point클래스의 멤버함수를 가리킬수 있다.
새로 정의한 타입의 이름은 *FP2이고 리턴은 void, 인자는 int를 가진 멤버 함수이다.
(pt.*fp2)(100);에서 어떤 객체의 멤버 함수를 호출할지 지정해줄 필요가 있다.
*fp2처럼 만들어서 '포인터가 가리키는 함수'를 의미.
함수 호출을 위한 () 연산자는 우선순위가 매우 높기 때문에 괄호를 사용한다.

정적 멤버 함수에 대한 포인터
정적 멤버 함수의 경우에는 멤버가 아닌 함수에 대한 포인터를 그대로 사용하면된다.
class Example{
public:
	static void Count();
}
typedef void (*FP)(); //여기서 typedef void (Example::*FP)();할필요없다는 뜻.
int main(){
	//함수의 주소 대입
	FP fp = &Example::Count;
	//함수 호출
	fp();
	return 0;
}
정적 멤버 함수는 원래부터 객체를 사용하지 않고 호출한다.

멤버 함수의 오버로딩
멤버 함수에서도 오버로딩이 가능하다.
21_36
Point.h Point.cpp 21_36.cpp
이름은 같고 시그니처만 다르기 때문에 오버로드된 멤버 함수가 된다.

객체의 배열
클래스토 타입의 한 종류기 때문에 배열을 만들 수 있다.
생성자와 관련한 문제를 생각해 보아야 한다.
생각하지않는다면
21_37.cpp
모든 객체의 값이 (0,0)이 된다.
즉, 객체의 배열을 정의할 때 각 객체들은 디폴트 생성자로 초기화됐다.
그러면 디폴트 생성자가 아닌 다른 생성자를 호출하려면
21_38.cpp
객체의 배열을 초기화할 때는 초기화 리스트에서 직접 생성자를 호출해주면 된다.

객체의 동적인 생성
기본 타입을 동적으로 할당하는 경우는 커다란 크기의 메모리 공간이 필요한 경우가 대부분.
하지만 객체의 경우에는 단순히 객체 하나만을 동적으로 생성하는 경우가 오히려 많다.
포인터를 사용해서 객체를 다뤄야 하는 일이 많다는 뜻.
상속과 관련해서도 포인터를 통한 객체의 사용은 매우 중요한 주제.

동적으로 객체 생성하기
객체를 동적으로 생성할 때도 new연산자를 사용한다.
객체의 경우 생성자의 호출이라는 문제가 있어 조금 다르다.
21_39.cpp
new 연산자에 이어서 타입의 이름을 적어주고 이어서 생성자를 호출해주는 부분이 있다.
Point* p2 = new Point(100, 100);
동적으로 생성된 객체의 주소를 보관할 포인터를 준비하고,
Point타입에 호출될 생성자 지정하고 인자전달하여 동적인 할당을 해준다.

생성자와 소멸자의 호출 시점
객체를 동적으로 생성할 때 생성자와 소멸자가 언제 호출되는지 정확하게 알아야 한다.
생성자는 new 연산자를 사용해서 동적으로 객체를 생성할 때 호출된다.
소멸자는 delete연산자를 사용해서 해제할 때 호출된다.
21_40.cpp
생성자의 호출:(정)객체를 정의할 때            (동)new 연산자로 할당할 때
소멸자의 호출:(정)객체를 정의한 함수가 끝날 때 (동)delete 연산자로 해제할 때

정적 멤버 함수에서 객체 생성하기
생성자가 private로 되어 있어 클래스의 외부에서 객체를 생성하는 것은 불가능.
하지만 멤버라면 가능하다.
그래서 정적 멤버 함수에서 객체를 동적으로 생성해 그 주소를 반환하게 만듦.
21_41.cpp
1)생성자가 private인 경우에도 정적 멤버 함수에서는 객체를 생성할 수 있다.
같은 '멤버'이기 때문에 가능
2)객체를 동적으로 생성해서 그 주소를 반환하는 수밖에 없다.
정적으로 할당하면 함수가 종료되면서 그 객체도 같이 소멸되니까 동적으로.

클래스에 넣을 수 있는 다른 것들
열거체
클래스 밖에서 정의하는 것과 크게 다르지 않다.
클래스의 안에서만 사용하거나 클래스와 관련된 열거체의 경우 클래스 소속으로 두면 좋다.
21_42 열거체사용
Point.h
이 열거체의 심볼을 클래스의 외부에서 참조하고 싶다면 영역 지정 연산자를 사용해서
Point::MAX_X와 같은 방식으로 사용할 수 있다.
열거체가 public이 아닌 private나 protected면 외부에서 접근 금지.

static const 멤버 변수의 사용
const속성을 가진 정적 멤버 변수라고 할 수 있다.
//Point클래스를 정의한다.
class Point {
public:
	static const MIN_X = 0;
	static const MAX_X = 100;
	static const MIN_Y = 0;
	static const MAX_Y = 100;
}
클래스 정의에서 멤버 변수를 초기화하는 것은 불가능하지만, static const는 허용.
어떤 컴파일러에서는 오류가 발생할지도. 그리고 실수아닌 정수 타입만 가능하다.
그래서 아직은 열거체사용하는 것이 일반적.

typedef
클래스 안에서만 통용하는 타입을 재정의하는데 사용할 수 있다.
나중에 소스코드를 수정하기가 쉽다.
21_43.cpp
Point.h
멤버 변수 x,y와 관련된 것은 모두 COOR_T로 바꿈.
나중에 int에서 float으로 바꾸고 싶으면
typedef float COOR_T; 해주면 된다.
클래스와 관련된 것이라면 클래스의 정의 안쪽에 위치시키는 것이 좋다.
응집력이 좋을수록 좋은 프로그램.

소프트웨어 공학의 기본적인 규칙
응집력(Coheision)을 높이고 연관성(Coupling)을 줄이는 것이다.
응집력을 높이는 것은 관련된 것을 한 곳에 모아서 함께 관리하는 것.
연관성을 줄이는 것은 관련 없는 것끼리는 서로를 모르게 만드는 것.
정보 은닉과도 비슷.

This 포인터
멤버 함수에는 This포인터가 숨어 있다.
컴퓨터에 의해서 자동적으로 만들어진 포인터.

멤버 함수 안에서 자기 자신을 확인하는 법
This 포인터는 자기 자신을 가리키고 있다.
pt라는 객체를 사용해서 멤버 함수를 호출했다면 This포인터는 pt 객체를 가리킴.
21_44.cpp
This포인터는 멤버 함수를 소유한 객체를 가리키고 있다.
멤버 함수를 호출할 때 사용한 객체를 가리키고 있다.
가상의 코드
WhoAmI* const this = &obj1;
멤버 함수를 매번 호출할 때마다 가상의 코드를 실행한다.

This 포인터의 타입
객체를 가리키는 것이므로 WhoAmI*타입일 것이고 다른 객체를 가리킬 순 없으므로 const.
//기본타입
int n = 10;
int* const p1 = &n //n의 값을 바꿀 수는 있지만 다른 변수는 가리킬 수 없다.
const int* p2 = &n //n의 값을 바꿀 수는 없지만 다른 변수는 가리킬 수 있다.
const int* const p3 = &n //n의 값을 바꿀 수 없고 다른 변수를 가리킬 수도 없다.
//클래스 타입
Point pt;
//pt의 멤버 변수의 값을 바꿀 수 있지만 다른 객체를 가리킬 수 없다.
Point* const ppt1 = &pt;
//pt의 멤버 변수의 값을 바꿀 수 없지만 다른 객체를 가리킬 수 있다.
const Point* ppt2 = &pt;
//pt의 멤버 변수의 값을 바꿀 수 없고 다른 객체를 가리킬 수 없다.
const Point* cont ppt3 = &pt;

정적 멤버 함수에는 this가 없다.
This포인터는 멤버 함수에만 있는 것이다.
This포인터는 멤버 함수를 소유한 객체를 가리키는 것이 임무인데
정적 멤버 함수는 객체의 소유가 아닌 클래스기 때문에 This포인터가 없다.
21_45.cpp
정적 멤버 함수는 this 포인터가 없다 - 오류 메시지

this 포인터로 이름 충돌 해결하기
멤버 함수 안에서 정의한 변수나 매개 변수의 이름이 멤버 변수와 동일한 경우에는
멤버 변수에 접근할 수 없었다.
그런데 this 포인터를 사용하면 이런 상황에서도 멤버 변수에 접근할 수 있다.
21_46.cpp
This포인터는 자기 자신을 가리키고 있기 때문에 this->id와 같은 표현으로 멤버변수.
그냥 id라고 적어준 것은 매개 변수.

정말로 멤버 함수는 객체마다 있는 것일까?
기본적으로는 맞지만 컴퓨터 내부는 그렇지 않다.
멤버 변수의 경우에는 각 객체의 정보가 보관되는 곳이기 때문에 어쩔 수 없이
객체마다 있어야 하지만 멤버 함수는 어차피 같은 내용이기 때문에 객체마다 있을필요없다.
컴퓨터입장에서는 메모리 낭비가 된다.
그래서 나온 것이 바로 This 포인터.
멤버 함수는 내부적으로 딱 하나만 존재하지만 이 멤버 함수를 호출하면서
This포인터를 넘기는 것이다.
모든 객체가 마치 자신의 멤버 함수가 있는 것처럼 동작.
멤버 함수는 각 객체마다 하나씩 있다고 생각해야 정적멤버함수와 혼동하지 않는다.

*/