/*
01 함수의 모든것
오버로딩(Overloading)
여러 함수들이 동일한 이름을 사용할 수 있는 기능을 말한다.
이름은 같으면서 인자의 종류만 다르다면 오버로드 되었다고 말한다.

함수의 시그니처
void Func1(int a, int b);
void Func2(char c);
함수의 시그니처란 함수의 원형에서 인자 부분을 의미한다.
int a, int b부분이 시그니처가 된다.

왜 오버로딩을 사용할까
int max(int a, int b);
float max(float a, float b);
이름은 동일하나 반환 값과 인자들의 타입이 다르다.
이 함수는 다루는 인자와 반환 값의 타입이 int인지 float인지와 상관없이 동일한 코드로 사용.
인자의 종류에 상관 없이 동일한 코드를 사용할 수 있다는 것이 장점.
비슷한 일을 하지만 인자의 타입이 다른 함수들을 오버로딩하는 것이 일반적.
이후에 '연사자의 오버로딩'을 배울 수 있다.
지금까지 배운 연산자들의 일을 바꿔버릴 수 있는 기능.

기본적인 오버로딩의 규칙
어떤 함수를 호출할지 결정하는 규칙
int VariableReturnType(char c, int i);
double VariableReturnType(char c, double d);
컴퓨터는 인자의 타입을 확인해서 그에 가장 잘 어울리는 시그니처를 가진 함수를 호출한다.

반환 값만 틀린 경우는 오버로드할 수 없다.
int VariableReturnType(char c, int i);
double VariableReturnType(char c, int i); //오류:반환 값의 타입만 다르다.
VariableReturnType('A', 100);을 호출하면 어떤 함수를 호출하고 싶은지 모른다.
즉 인자의 타입을 보고 호출할 함수를 결정하기 때문.

시그니처가 다르더라도 오버로드할 수 없는 경우
void SameSignature(int i);
void SameSignature(int& r);
SameSignature(10);을 호출했을 때 어떤 함수를 호출하고 싶은지 모른다.

적당한 함수를 찾는 순서
인자의 타입과 매개 변수의 타입이 정확하게 일치해야만 함수를 호출할 수 있는 건 아니다.
void CallMe(int n);
int main(){
	CallMe('A');
	return 0;
}
같은 경우에도 합법적인 호출.
char 타입은 int 타입으로 자동적으로 형변환이 되고 정수형 승진이 된다.
이렇게 되면 호출될 수 있는 함수의 후보가 많아질 수 있다.
void CallMe(int n);
void CallMe(char c);
그전에는 원천적으로 함수를 선택할 수 없는 경우지만, 지금은 선택할 여지가 있다.
CallMe((int)'A');
CallMe((char)'A');
이렇게 해주지 않는 경우에는 컴퓨터 나름대로의 규칙을 가지고 우선 순위가 높은 함수를 호출.
1)정확하게 일치하는 경우(Exact Match)
2)승진에 의한 형변환(Promotion)
3)표준 형변환(Standard Conversions)
4)사용자에 의한 형변환(User-defined Conversions)
승진에 의한 형변환이란 bool, char, short타입 등의 int 타입으로 자동적으로 형변환하는 경우.
float가 double로 되는 경우도 승진.
표준 형변환이란 승진에 의한 형변환을 제외한 암시적인 형변환을 의미한다.
사용자에 의한 형변환은 클래스를 배운 후에 배울 수 있다.
void WhichOne(float f);
void WhichOne(double d);
void WhichOne(int c);
int main(){
	WhichOne(3.5f);
	return 0;
}
여기선 float타입의 함수를 호출하게 된다. 이게 없다면 double로의 승진되어 호출된다.
마지막으론 float에서 int로의 표준 형변환이 이루어지면서 함수를 호출한다.

디폴트 인자
Default는 따로 지정해주지 않았을 때 기본적으로 선택하는 값을 말한다.
디폴트인자는 따로 값을 지정해주지 않은 경우에 선택하는 인자의 값.
디폴트 인자의 경우에는 함수를 호출할 때 해당 인자의 값을 적어주지 않아도 된다.
호출한 함수의 안쪽에서는 마치 사용자가 디폴트 인자의 값을 넘겨준 것처럼 보인다.

명칭 장식
C++에서는 함수의 이름에 대해서 명칭장식(Name Decoration or Name Mangling)을 수행.
함수의 이름에 이상한 기호들을 붙여서 컴퓨터가 이해하기 쉬운 이름으로 바꾸는 것을 말함.
void WhichOne(char c);
내부적으로는 ?WhichOne@@YAXH@Z와 같은 복잡한 이름. 시그니처와 관련한 정보를 토대로 만들어짐.
그래서 오버로드된 함수들도 컴퓨터 입장에서는 다른 이름을 가진 함수이다.

디폴트 인자의 사용
15_1.cpp
함수의 원형에서 매개 변수의 이름 뒤에 디폴트 값을 적어주면 된다.
함수를 호출할 때 이 인자에 대해서 아무런 값도 넘겨주지 않게 되면 디폴트 값이 사용.
디폴트 인자는 호출하는 사람이 적당한 값을 모르는 경우에 길잡이가 되어줄 수 있다.
매번 함수를 호출할 때마다 똑같은 인자의 값을 타이핑하는 것을 피하는 용도도 될 수 있다.
물론 디폴트 값이 있는 경우에도 직접 인자를 넣어주는 것이 가능하다.
SetFramesPerSec(5);

디폴트 인자가 2개 있는 경우
void DefaultArgs(int a = 1, int b, int c = 3);
DefaultArgs(100, 200);
위의 함수는 문법적으로 올바르지 않다.
C++는 디폴트 인자를 만드는데 있어서 제한이 있다.
1)모든 디폴트 인자는 오른쪽 끝에 모여 있어야 한다는 것이다.
void DefaultArgs1(int a, int b = 2, int c =3); //ok
void DefaultArgs2(int a, int b, int c =3); //ok
void DefaultArgs3(int a = 1, int b = 2, int c); //no
void DefaultArgs4(int a = 1, int b, int c = 3); //no
void DefaultArgs5(int a = 1, int b, int c); //no
이렇게 해야지만 함수를 호출할 때 컴퓨터가 혼동하지 않고 인자와 매개 변수를 매칭.
void DefaultArgs(int a, int b = 2, int c = 3);
Default(100, 200); //a=100, b=200, c=3
즉, 왼쪽에 있는 매개 변수부터 하나씩 인자와 짝을 지어주는 것.

오버로딩과 디폴트 인자의 충돌
void Ambiguous(int a, int b = 100);
void Ambiguous(int a);
Ambiguous(50);
어느 함수를 호출해야 할지 결정할 수 없게 된다. 이런 경우는 허용하지 않는다.

재귀호출(Recursion)
함수가 자기 자신을 호출하는 경우.

기본적인 재귀 호출의 사용
15_2.cpp
호출을 영원히 계속 반복하게 되지만 실제로는 영원하진 않다.
함수를 호출할 때 약간의 메모리 공간을 사용하게 되는데, 이 메모리는 함수의 실행이 끝나면서 반납.
그런데 함수가 끝나지 않고 계속 호출만 하면 메모리가 부족해지고 그로 인한 오류 발생.
고려해야 할 사항은 "언제 재귀 호출이 끝나게 할 것인가?"
영원히 호출할 수는 없으므로 특정 상황이 되면 재귀 호출이 끝날 수 있게 해야 한다.
15_3.cpp
재귀 호출 전의 코드들은 함수가 호출된 순서대로 실행된 것이고,
재귀 호출 후의 코드들은 함수가 종료된 순서대로 실행된 것.

스택(Stack)
쌓아올린 더미를 의미한다. 자료들을 저장하는 공간의 일종.
결국 메모리에 저장하는 것이지만, 저장 방식이 접시를 쌓는 법과 같다.
기본 성질은 먼저 보관한 것이 가장 나중에 나온다는 것이다. FILO
자기 위에 있는 접시들이 모두 제거되야 처음에 호출된 함수가 종료될 수 있다.
모든 함수의 호출은 내부적으로 스택을 사용하게 된다.
그렇기 때문에 함수가 끝난 후에야 main()함수도 끝날 수 있게 된다.

재귀 호출의 활용
커다란 정보가 있다고하고, 이 정보에 반복적으로 동일한 작업을 해줘야 된다고 하자.
그렇게 반복하는 과정에서 이 커다란 정보는 점점 작아진다고하자.
그러면 결국 반복을 종료할 수 있다.
게다가 각 반복 과정에서 나온 중간 결과들을 거꾸로 모아야 한다면 더욱 좋다.
10진수의 값을 2진수로 바꾸는 함수.
알고리즘은 10진수를 계속해서 2로 나누면서 나머지를 적어가는 방식.
15_4.cpp
Convert2Bin()함수가 하는 일은 '2로 나누어서 나머지를 적고, 몫을 아래쪽에 다시적는' 작업.
2진수의 자리 수 하나를 구할 수 있기 때문에 재귀적으로 여러 번 호출하면 모든 자리 수.
재귀함수의 특징은
1)반복적으로 작업을 수행한다. 10진수 값을 2로 나누고 나머지를 기입하는 동일한 작업.
2)재귀 호출이 진행되면서 값이 줄어들게 된다. 그리고 종료할 수 있게 한다.
3)각 함수에서의 계산 결과를 거꾸로 수집할 수 있다는 점.

함수에 대한 포인터
포인터는 함수를 가리킬 수 있고 포인터를 사용해서 호출하는 것도 가능하다.

함수를 가리킨다는 것의 의미
컴퓨터에서 정보를 보관하는 곳은 크게 주기억 장치와 보조 기억 장치.
컴퓨터가 어떤 정보를 가지고 일을 하려면 그 정보는 반드시 메모리에 존재해야 한다.
하드디스크에 있는 정보라면 하드디스크에서 메모리로 복사한 후에 사용할 수 밖에 없다.
함수를 호출하기 위해서는 함수가 메모리에 존재해야 한다.
우리가 만든 소스코드는 컴퓨터만 이해할 수 있는 정보로 변환되어 메모리에 존재한다.
바로 이 위치의 주소를 포인터가 보관할 수 있는 것이다.
함수의 경우에는 값을 읽거나 쓰는 용도는 불가능하고 함수의 포인터를 이용해 함수를 호출.
호출할 함수의 주소를 포인터에 담아서 건네주면 된다.

기본적인 함수의 포인터 사용.
15_5.cpp
변수를 가리키는 포인터와 크게 다른 부분은 없다.
하지만 일반적으론 변수들을 보관하는 메모리 공간과 함수들을 보관하는 메모리 공간은 떨어져있다.

함수의 포인터를 정의하는 방법
함수의 포인터를 정의할 때도 포인터가 가리킬 수 있는 함수의 종류를 지정해주어야하는데,
함수의 종류란 함수의 반환 값과 시그니처를 의미한다.
우선 그 포인터가 가리킬 수 있는 함수의 종류를 결정한다.
'반환 값이 없고 인자도 없는' 함수면
void AnyName();
이 상태에서 함수의 이름 부분만 변경.
void (*p)();
이렇게 하면 변수 p는 '반환 값이 없고 인자도 없는' 함수에 대한 포인터가 된다.
int MyFunction(int a, char* p); 같은 경우에는
int (*ptr)(int, char*); 'int타입을 반환하고 두 개의 인자를 받는' 함수에 대한 포인터.

함수의 포인터와 관련한 다양한 표기법
(*p)(); == p(); 이지만 사람이 보면 헷갈릴 수 있어 지양.
p = &Dog; == p = Dog; 이지만 사람이 보면 헷갈림.
함수의 이름 자체가 함수의 주소를 의미해서 가능하다.

typedef를 사용한 함수의 포인터 정의
typedef를 사용해서 함수의 포인터를 정의하는 일을 간단하게 만들 수 있다.
int (*Func1)(int, int);
int (*Func2)(int, int);
void (*Func3)(int);
void (*Func4)(int);
int (*Func5)(int, int);
에서 Func1, Func2, Func5는 같은 종류의 함수를 가리킬 수 있다.
typedef int (*FN_TYPE1)(int, int);
typedef void (*FN_TYPE2)(int);
FN_TYPE1 func1;
FN_TYPE1 func2;
FN_TYPE2 func3;
FN_TYPE2 func4;
FN_TYPE1 func5;
typedef를 사용해서 함수의 포인터 타입에 대한 다른 별명을 만들어 줄 수 있다.

만드는 법
가리키기를 원하는 함수의 원형을 적어준다.
int AnyName(int a, int b);
원형 앞에 typedef를 붙여주고 이름 부분을 바꾸고 인자 이름 제거.
typedef int (*FN_TYPE1)(int, int);
FN_TYPE1은 'int타입을 반환하고 두 개의 인자를 갖는 함수에 대한 포인터 타입'

함수의 포인터 활용하기
함수의 포인터를 다른 곳에 넘겨 받은 함수에서 함수가 필요할 때 호출할 수 있게 하는 법.
만약 어떤 함수가 중요한 일을 하고 있다고 생각해보자.
이 함수의 몇몇 곳에서는 시스템에 관련된 기능을 사용해야 한다.
하지만 윈도우 버전에 따라 호출되야 하는 함수가 다르다.
1)중요한 함수 안에서 매번 자신이 실행하는 환경을 검사해서 적당한 함수를 호출하면 된다.
15_6.cpp
매번 실행 환경을 검사한다는게 문제.
괜한 시간 낭비할 것 없이 프로그램이 시작할 때 한 번만 비교하는 것으로 충분하다.
또한, 동일한 코드가 중복해있다는 점.
2)함수의 포인터를 사용한 개선
15_7.cpp
함수의 포인터를 넘기는 쪽은 main(). 받는 쪽은 ImportantFunc(). 가리키는 함수 For()
main()함수는 시스템의 버전을 확인해 ImportantFunc()가 어떤 함수를 호출해야 하는지 알고 있다.
main()은 ImportantFunc()이 언제 ForWindows9x()나 ForWindowsNT()를 호출할지 모른다.
그러니 포인터를 주어서 필요할 때 호출할 수 있게 해준다.

*/