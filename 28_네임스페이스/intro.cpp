/*
01 네임스페이스 사용하기
관련된 코드별로 그룹을 나누어서 관리하면 매우 효율적인데 네임스페이스가 가방역할.

왜 네임스페이스를 사용해야 할까
정의한 이름들이 모두 한 공간에 위치한다.
서로 다른 소스파일에 위치한다고해도 컴퓨터의 입장에서는 모두 한 곳에 정의한 것과 같다.
폴더 개념이 없는 하드디스크에 비유할 수 있다.
분명 많은 파일들이 서로 이름 충돌을 일으킬 것이고, 꺼내오는 것도 힘들다.
C++에서는 네임스페이스가 폴더와 같은 역할을 한다.
가상의 폴더에 넣어서 보관하게 되면 이름이 충돌할 염려도 없고 관련한 코드들을 한 곳에 모을 수 있다.
가장 큰 장점은 소스파일과 코드를 구조적으로 관리할 수 있다.
Data네임스페이스 안에는 정보를 저장하거나 읽어오는 작업에 관련된 코드,
UserInterface네임스페이스 안에는 프로그램의 UI와 관련된 코드들을 넣어두게 되면 관리하는데 많은 장점을 갖는다.
어떤 클래스가 무슨 일을 하는지 몰라도 네임스페이스 이름을 보고 유추할 수도 있다.
우리가 하드디스크에 폴더를 만들어서 파일을 관리하는 것과 같다.

네임스페이스의 기본적인 사용법
네임스페이스 안에서 정의하기
일반적으로 전역 공간에 정의할 수 있는 것이라면 무엇이든지 네임스페이스 안에서도 정의할 수 있다.
28_1.cpp
namespace키워드를 사용해서 네임스페이스의 이름을 적어주고 중괄호로 블록을 만들면 된다.
네임스페이스 블록 안에 정의한 이름들은 해당 네임스페이스 안에 소속된다.
같은 이름들이 중복되고, count라는 이름은 전역 공간에 정의한 것까지 3개가 있다.
하지만 컴퓨터는 오류를 발생시키지 않는다.
서로 다른 네임스페이스라면 얼마든지 동일한 이름을 사용할 수 있기 때문.
마치 하드디스크에서 서로 다른 폴더라면 같은 이름의 파일이 존재할 수 있는 것.

네임스페이스 안에서 정의한 변수는 전역변수가 아닌가요?
네임스페이스 안에서 정의했더라도 전역 변수에 해당한다.
접근범위와 존속기간 역시 전역 변수와 동일하다.
네임스페이스 안에서 정의했기 때문에 사용할 때 부가적으로 해주어야 할 일이 있기는 하지만 여전히 모든 파일에서 접근 가능.

네임스페이스 안에서 정의한 이름 사용하기
28_2.cpp
오류 메시지가 출력된다.
무작정 이름을 사용하게 되면 컴퓨터는 이 이름들을 전역 공간에서만 찾게 된다. 하지만 이 이름들은 네임스페이스 안에서
정의했기 때문에 찾을수가 없는 것이다.
그러므로 네임스페이스 안에서 정의한 이름을 사용하기 위해서는 "Cat이라는 네임스페이스안에 있는 함수를 호출해주렴"과 같은방식.
28_3.cpp
::라는 연산자는 실제로 '영역지정연산자(Scope resolution operator)'라는 이름.
클래스의 멤버를 가리키거나 네임스페이스에 소속한 이름을 가리킬 때 사용한다.
더 편한 방법으로 "지금부터 말하는 이름들을 Cat네임스페이스에 소속한 이름들을 말하는 거야"라고 선언해줄수도 있다.
using namespace Cat;
네임스페이스Cat을 공공연히 사용할 수 있도록 만들어준다.
그냥 CreateAll()이라고만 적어주어도 Cat::CreateAll()을 의미한다.
만약 main()함수에서만 한다면 유용할 수 있지만 야옹이와 멍멍이 모두 작업을 한다면 권장하지 못한다.
using namespace Cat;
using namespcae Dog;
을 사용하면 count는 다양한 후보를 갖게되고 컴퓨터는 어떤 이름을 사용해야 할지 모르겠다는 오류를 발생시킨다.
이런 경우라면 다시 Cat::count나 Dog::count처럼 사용하는 수밖에 없다.
using 키워드를 사용해 네임스페이스 전체를 지정하는 것뿐만 아니라 네임스페이스에 소속된 특정 이름만 지정하는 것도 가능하다.
28_6.cpp
using Cat::CreateAll;
"이제부터 말하는 CreateAll은 Cat네임스페이스에 소속한 CreateAll을 말하는거야"

전역공간에서 정의한 변수를 직접 사용하는 방법은 없나요?
::count처럼 영역지정연산자 앞에 아무런 이름도 적어주지 않으면 전역 공간에서 정의한 변수를 의미하게 된다.
가장 최근에 정의한 변수가 이전에 정의한 변수를 숨기는 것이 C++의 규칙이었다.
하지만 방금 배운 방법을 사용하면 같은 이름의 지역변수가 있는 경우라도 직접적으로 전역 변수를 사용할 수 있게 된다.

using키워드의 두 가지 사용법
네임스페이스를 지정하는 방법과 네임스페이스에 소속된 특정한 이름을 지정하는 방법에 대해서 배웠는데
네임스페이스에 소속된 특정한 이름을 사용할 때는 주의해야 할 점이 있다.
Cat::CreateAll이라는 이름은 전역 공간에 다시 한번 선언되는 효과를 갖는다.
마치 전역 공간에 CreateAll()이라는 함수를 선언한 것과 같다는 뜻.
void CreateAll(); 이라는 함수를 추가한다면 오류가 발생한다.
전역 공간에 CreateAll()이라는 이름의 함수가 2개나 존재하는 셈이어서.

C++표준 라이브러리와 std네임스페이스
cout 객체 사용법 분석하기
cout 객체를 사용할 때마다 <iostream>헤더파일을 포함시키고
using namespace std;
"이제부터 std네임스페이스에 있는 이름들도 그냥 사용할 수 있게 해주렴"
cout, cin을 비롯한 C++의 표준라이브러리와 관련한 코드들은 std라는 이름의 네임스페이스 안에서 정의되어 있다.
단순히 std 네임스페이스 안에 정의된 cout객체 등에 접근하기 위한 목적으로 적었었다.
네임스페이스에 소속한 이름에 접근하는 방법은 다양하다.
28_7.cpp
std 네임스페이스를 지정하는 코드를 제거하는 대신 std::cout처럼 사용함.
일반적으로 cout객체를 사용할 때는 이와 같은 방법을 사용하는 것이 바람직하다.
명확하고 불필요한 이름 충돌을 막을 수 있기 때문에.

네임스페이스와 소스 파일의 관계
네임스페이스와 소스파일은 독립적인 관계다.
하나의 네임스페이스가 여러 파일에 걸쳐서 존재할 수도 있고, 한 파일 안에 여러 네임스페이스가 존재할 수도 있다.
멍멍이와 야옹이는 한 파일 안에 Dog와 Cat네임스페이스가 존재했었다.
표준라이브러리와 관련된 코드들은 모두 std네임스페이스 안에 소속되어 있지만 수백 개의 소스파일에 나뉘어서 존재한다.
실제로 네임스페이스를 사용할 때는 후자와 같은 방식을 사용한다.
왜냐하면 네임스페이스의 목적이 수많은 파일과 코드를 관련된 것끼리 모으는 것이기 때문이다.
'네임스페이스가 여러 소스 파일을 담는 논리적인 가방'이라고 생각하자.
28_8
cat.h cat.cpp dog.h dog.cpp 28_8.cpp
cat.h와 cat.cpp 모두에서 네임스페이스 블록을 만들어주었다는 점이다.
서로 다른 파일에서 만든 Cat네임스페이스지만 컴퓨터 입장에서는 모두 동일한 Cat 네임스페이스.
이런 방식을 사용해서 수많은 파일에 걸쳐서 존재하는 코드들을 하나의 네임스페이스 안에 담을 수 있다.

cat.h에 있는 변수에는 왜 extern 키워드가 붙여있나요?
다른 파일에서 정의한 변수를 사용하겠다고 선언하는 의미이다.
다른 모든 헤더 파일은 cpp파일에 의해서 포함되기 위한 것.
즉, cat.cpp에 정의된 cats나 count변수에 접근할 수 있게 만드는 역할.

네임스페이스가 가진 그 밖의 기능
이름 없는 네임스페이스
이름을 적지 않으면 네임스페이스에 소속된 이름들을 다른 파일에 숨기는 결과를 가져온다.
28_9.cpp 28_9_2.cpp
같은 파일의 경우에는 사용할 수 있지만 다른 파일의 경우에는 다르다.
extern키워드를 사용하고 있지만, 그런 변수가 없다는 오류.
이름 없는 네임스페이스를 사용하면 다른 파일에서 접근할 수 없게 만들 수 있다.
static키워드를 사용해서 전역변수나 함수를 정의한 경우에도 동일한 효과.
현재는 static을 주로 사용한다. C언어에서도 사용하기 때문에.
C++ 표준문서에서는 사실 이름없는 네임스페이스를 사용하는 것을 권장하고 있다.

중첩된 네임스페이스
네임스페이스 안에 또 다른 네임스페이스를 만드는 것이 가능하다.
28_10.cpp
'Data네임스페이스 안에 User네임스페이스 안에 정의한 변수 number'를 의미한다.

네임스페이스를 별명으로 부르기
네임스페이스의 이름이 너무 긴 경우에는 간단한 별명을 붙여준 후에, 별명을 대신 사용할 수 있다.
28_11.cpp
긴 이름의 네임스페이스 뿐만 아니라 여러 번 중첩된 네임스페이스에도 별명을 붙여줄 수 있다.
namespace ah = Data::User::Free;

네임스페이스는 사용법이 아주 간단하면서도 소스 코드를 구조적으로 만드는 데 많은 도움을 주는 기능.
네임스페이스를 사용하는 습관을 들이자.

*/