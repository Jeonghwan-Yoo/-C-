/*
01 함수의 기본
좋은 프로그램을 짜는 지름길.

왜 함수를 사용해야 할까
함수의 개념을 올바르게 정립하고 함수가 갖는 의미를 올바르게 이해하는 게 중요하다.
함수는 코드를 포함하고 있다.
원하는 개수의 함수를 만들 수 있다.
main()은 특별한 함수로 항상 main()부터 시작한다.
관련이 있는 코드를 한 데 모으는 것이 중요한데, 함수가 코드를 담는 가방역할을 한다.
함수를 사용해서 소스 코드를 잘 정리해두는 것은 단순히 관리의 효율성이상의 효과.
또한, '소스코드의 재사용'. 훌륭한 '도구'로써 도움을 준다.
C++에서는 이미 만들어진 많은 함수들을 제공한다. 수학함수, 시스템함수 등등
함수를 정의하는 법을 배운 후에 이미 만들어진 함수를 사용하는 법을 배워야 한다.
최종적으로는 '어떤한 기준으로 함수를 만들 것인가?'

아주 기본적인 함수의 사용
14_1
//데이터를 압축하는 함수
//pBufIn:입력데이터
//pBufOut:출력데이터
//nActualDataLength:데이터의 크기(in,out)
//반환 값:성공 여부
int Compress(const char* pBufIn, char* pBufOut, int& nActualDataLength) {
	if (NULL == pBufIn || NULL == pBufOut || 0 == nActualDataLength) {
		return INVALID_ARGUMENT;
	}
	int nOutputDataLength = 0;
	for (int i = 0;i < nActualDataLength;++i) {
		//데이터를 압축하는 코드
	}
	nActualDataLength = nOutputDataLength;
	return OK;
}
이런식으로 작성되기도 한다.

14_2.cpp
PrintMessage()를 만나면 그 함수로 가서 끝까지 실행한 후에 함수호출한 다음 위치로 돌아온다.
프로그램은 항상 main()함수에서 시작한다.
14_3.cpp
PrintMessasge()를 아래로 옮기면 오류를 발생한다.
변수를 먼저 정의해야 하는 것처럼 함수도 미리 정의해야 한다.
다른 방법으론 PrintMessage()가 아래 있다는 것을 알려주면 된다.
14_4.cpp
void PrintMessage()한 줄에 함수를 호출하기 위한 모든 정보가 들어있고 
함수의 원형(prototype)이라고 부른다.
즉 함수의 위치는 함수는 자신을 호출하는 함수 앞이나 함수의 원형만 앞쪽에.

반환값(Return Value)
함수는 실행된 후에 다시 호출한 곳 다음 줄로 돌아가는 데 이때 함수는
하나의 값을 가지고 되돌아 갈 수 있다. 이 값을 반환 값이라고 한다.
14_5.cpp
Three()함수의 실행이 끝나고 돌아오면서 반환 값을 ret변수에 저장한다.
int는 반환 타입, Three는 함수 이름.
return 명령은 두 가지 의미를 가지고 있다.
이제 함수의 실행을 끝내라는 의미고, 뒤에 나오는 값을 반환하라는 의미이다.
반환하지 않을 때는 void타입으로하고, return;을 써줘도 된다.

그러면 main()함수가 반환하는 것은 누가 받나요?
return 0을 하고 있었다.
실제로는 C++에서 제공하는 다른 함수가 main()함수를 호출하게 된다.
이 함수는 main()함수에서 반환한 값을 운영체제에게 다시 전달한다.
그러면 운영체제는 이 프로그램을 실행한 프로그램에게 그 값을 반환한다.
0을 반환하는 것은 일반적으로 '정상'을 의미한다.
구체적인 방법에 대해서는 셸프로그래밍이나 윈도우즈 API자료를 찾아야 한다.

다른 함수에 있는 변수의 사용
14_6.cpp
a라는 변수가 정의되지 않았기 때문에 오류를 발생.
C++에서는 다른 함수에 있는 변수는 사용할 수 없다.
그래서 만든 함수 안에서 아무 변수 이름을 또 지을 수 있는 자유.
변수 a처럼 같은 이름의 변수일지라도 서로 다른 함수에 정의한 변수들은
각자의 메모리 공간을 가지고 있고 전혀 다른 변수이다.

02 인자의 전달
인자 전달의 기본
관련된 개념을 확실하게 잡아두는 것이 중요하다.

왜 인자를 전달해야 할까
인자라는 것은 함수를 호출하면서 함께 넘겨주는 값을 의미한다.
함수에게 일을 시킬 때 함수에게 필요한 정보를 넘겨줄 필요가 있다.
인자의 종류는 모든 타입이 된다.

아주 기본적인 인자 전달
14_7.cpp
함수의 이름에 이어지는 괄호 안에 인자의 타입과 이름을 넣어준다. 인자는 여러개있어도 된다.
int n은 첫번째 인자는 int타입이고 인자의 값을 n이라는 이름으로 사용한다는 의미.
5의 값은 Factorial()의 n이라는 변수에 대입이 된다.
result서로는 이름이 같을 뿐, 전혀 다른 변수이다.

인자가 있는 함수의 원형
사실 인자의 타입까지만 적어주어도 무방하다.
int Factorial(int);
이 함수를 호출하기 위해서 필요한 최소한의 정보를 제공하기 위한것이다.
물론 이름까지 적어주는 것이 가독성에 더 좋아서 적어주는 것이 일반적.

Factorial()함수의 의미
팩토리얼을 구할 필요가 있을 때면 어디서든 호출하기만 하면 된다.
Copy & Paste는 개발자의 안좋은 습관이다. 동일한 코드가 여러 군데 존재하기 때문.
사실 미리 계산된 값을 배열에 넣어두었다가 꺼내서 반환하는 방식으로 개선할 수 있다.
코드들을 일일이 찾아 다니면서 고쳐주는 것은 쉬운 일이 아니다.
함수는 관련된 코드를 모아서 하나의 도구로 만들어 준다.
그저 자신이 건네준 인자의 팩토리얼 값만 반환해주면 대만족.

인자 전달의 원리
인자 전달에 대한 규칙과 컴퓨터 안쪽에서 일어나는 일에 관한 것.
14_8.cpp
인자가 두 개 이상인 경우에는 콤마를 사용해 구분해줄 수 있다.
인자의 순서대로 값이 대입되는 것이다.
이는 마치 max()함수 앞에
int a = 3;
int b = 5;
가 있는 것과 같다.
실제로 C++에서 a,b는 max()함수 안에서 정의한 변수처럼 취급한다.
이런 변수를 매개변수(Parameter)라고 부른다.
즉, 함수를 호출하면서 인자를 전달하고 매개 변수는 인자의 값으로 초기화된다.
그리고 그 함수 안에서는 매개 변수를 통해서 인자의 값을 사용하게 된다.

삼항 연산자의 해석
int max(int a, int b){
	int max_value;
	if (a > b)
		max_value = a;
	else
		max_value = b;
	return max_value;
}

인자의 전달과 메모리 구조
앞서 배운 인자 전달의 규칙으로 모든 걸 이해할 수 있다.
14_9.cpp
가상의 코드를 만들면 max()가 시작되면서
int a = arg1;
int b = arg2;
인자가 변수라고 해도 달라지는 것은 전혀 없다.
주소               주소                주소
100                100                 100
104                104    b 5          104
108                108    a 3          108
112                112                 112
116                116                 116  ret 5
120 arg2 5         120 arg2 5          120 arg2 5
124 arg1 3         124 arg1 3          124 arg1 3
함수호출 전         함수호출            함수반환
max()함수가 실행을 종료하면 매개변수 a,b는 소멸된다.
매개 변수를 포함해서 함수 안에서 정의한 변수들은 자신이 속한 함수를 종료할 때 함께 소멸.
중요한 것은 인자와 매개 변수는 서로 다른 메모리 공간에 자리잡고 있는 서로 다른 변수이다.

복합 타입을 전달하기
포인터의 전달
포인터의 용도 중에서 중요한 부분을 차지하는 것이 포인터의 전달.

포인터를 전달하지 않으면 안되는 경우
GCD와 LCM을 구하는 함수의 예제.
두 개의 정수를 인자로 넘겨주면 GCD와 LCM을 계산하고 그 결과를 반환 받을 수 있는 함수가
필요한데, 반환받아야 하는 값이 2개가 된다.
이런 경우에는 결과를 받아올 변수를 인자로 넘겨주는 방법을 생각해볼 수 있다.
즉, 결과를 받을 변수를 인자로 전달해주면 함수 안에서 결과 값을 그 변수에 넣어주는 방식.
아래코드는 제대로 작동하지 않는다.
14_10.cpp
그 이유는 main()의 gcd,lcm과 GCD_LCM()의 gcd,lcm이 전혀 다른 메모리 공간에 다른 변수.
int gcd = gcd;
int lcm = lcm;
만 봐도 단순히 값만 대입된 것 뿐이다. 그 외의 관계는 존재하지 않는다.

유클리드의 호제법
a와 b의 GCD를 구한다고 할 때, a는 다음과같이 표현된다.
a = m * b + r //m은 a를 b로 나눈 몫이고 r은 나머지가 된다.
여기서 a, b의 GCD는 b,r의 GCD와 같다는 원리를 사용하는 것이 유클리드 호제법
그리고 b, r을 다시 a,b로 두고 연쇄적으로 적용하는 것이 가능하다.
최종적으로 r = 0이 되면, b의 값이 GCD가 된다.

포인터를 사용해서 해결하기
14_11.cpp
매개 변수의 타입이 int*인데, 왜 인자는 &gcd, &lcm처럼 변수의 주소를 넘겨주어야하는 걸까?
int* pgcd = &gcd;
int* plcm = &lcm;
포인터 변수기 때문에 주소 값을 보관하는 것이 이치에 맞다.
main()함수의 gcd, lcm변수를 가리키고 있는 것.
*pgcd, *plcm에 결과 값을 넣는 것은 결국 gcd, lcm에 결과 값을 넣는 것과 같다.
정리해보면
1)함수의 매개 변수는 포인터 타입으로 정의한다.
2)인자를 넘겨줄 때는 값을 담고 싶은 변수의 주소를 넘겨준다.
3)함수 안에서 결과를 넘겨줄 때는 매개 변수가 가리키는 곳에 값을 넣어준다.

구조체를 사용해서 2개의 값을 반환하기
2개 이상의 결과를 반환받기 위한 다른 방법이 몇가지 더 존재.
구조체 변수는 그 안에 여러 개의 멤버를 가지고 있기 때문에,
구조체 변수 하나만 반환하더라도 실제로는 여러 개의 변수를 반환하는 효과
14_12.cpp
반환 값의 타입을 구조체 RetValues타입으로 지정. 구조체 변수를 반환.

레퍼런스의 전달
레퍼런스가 도입되기 전에는 포인터 타입의 인자를 사용하는 것이 유일한 접근이었다.
이제는 레퍼런스가 보다 효율적인 방법을 제공하게 되었다.
14_13.cpp
엠퍼센드를 넣기만했는데 원하던 결과가 나온다.
int& gcd = gcd;
int& lcm = lcm;
매개 변수 gcd, lcm은 레퍼런스 변수기 때문에 참조할 변수를 사용해 초기화해주어야 하는 것.
기존에는 값이 복사만됐지만, 지금은 참조되고 있는 것. 메모리 공간 차지도 안한다.
레퍼런스 타입의 인자를 사용해서 함수의 결과 값을 얻어오는 방법을 정리해보면
1)함수의 매개 변수는 레퍼런스 타입으로 정의한다.
2)인자를 넘겨줄 때는 값을 담고 싶은 변수를 그대로 넘겨준다.
3)함수 안에서 결과를 넘겨줄 때는 매개 변수에 값을 넣어준다.

포인터와 레퍼런스의 비교
레퍼런스를 추천한다. 사용이 쉽고, 안전하기 때문.
포인터 타입의 매개 변수를 사용할 때, 가장 큰 위험은 NULL값이 넘겨져 오는 경우.
NULL말고도 이상한 값이 넘겨오면 심각한 문제가 발생한다.
그래서 올바른 주소라고 100%확신할 수 없으면 비교하는 코드를 추가해야한다.
bool GCD_LCM(int a, int b, int* pgcd, int* plcm){
	if (NULL == pgcd || NULL == plcm)
		return false;
	...
	return true;
}
함수를 호출한 쪽에서 함수의 성공여부를 반환값을 통해서 확인할 수 있게 된다.
반면 레퍼런스 타입의 매개변수의 경우에는 이상한 인자가 입력될 가능성이 없다.
그럴 경우 프로그램 시작되기 전에 오류가 발생하기 때문.

배열의 전달
기본적인 배열의 전달
겉으론 배열을 전달하는 것이지만, 실제적으로는 포인터를 전달하는 점.
14_14.cpp
매개 변수의 타입을 적어줄 때 '배열의 원소 개수'는 적어주지 않았고,
호출한 함수에서 변경한 내용이 함수 밖의 배열에 영향을 미친다는 점.
이것은 사실 배열 타입의 인자가 실제로는 포인터를 사용한다는 점과 관련.
char* arr = array;
그리고 배열의 이름은 첫번째 원소의 주소라는 것.
char* arr = &array[0];
그래서 매개 변수 arr은 인자로 넘겨운 주소 값으로 초기화된다.
이것은 마치 arr이 array의 다른 이름인 것처럼 사용할 수 있다.
둘다 &array[0] 값을 넘겨주는 것이기 때문.
arr[12]는 사실 *(arr + 12)와 동일.
배열의 경우에는 포인터나 레퍼런스를 사용하지 않아도 변경이 반영된다는 사실을 기억하자.
어차피 포인터를 사용하므로 '배열의 원소 개수'는 필요치 않는다.
정리해보면
1)매개 변수의 타입을 적어줄 때는 '배열의 원소 개수'부분은 적지 않는다.
2)인자로 넘겨줄 때는 배열의 이름을 넘겨준다.
3)인자로 넘겨온 배열을 사용할 때는 그냥 평범한 배열을 사용하듯이 하면 된다.

왜 C++에서 이런 방식으로 배열을 전달할까?
원소가 20개인 배열이 있다고 하면 호출된 함수가 시작되면서 원소가 20개인 배열을 새로
생성한 후에 20개의 원소 값을 모두 복사해야 할 것이다.
그러면 그만큼의 메모리 공간을 소모하고, 시간을 소모한다.
그냥 단수히 읽는 용도라고 하면 복사하면서 공간낭비를 할 필요도 없다.

const를 사용해서 배열을 보호하자
호출된 함수의 안쪽에서 배열의 내용을 변경하면 배열의 원본이 영향을 받는다.
const를 사용해서 배열의 수정을 막을 수 있다.
void UsingArray(const char arr[]){
	cout << "In UsingArray() : " << arr << "\n";
	arr[12] = '?';
}
함수원형도 똑같이 수정해야 한다.
const char* arr = array;
이 경우 에는 '포인터가 가리키는 변수의 내용'을 바꿀수 없다는 의미.
그리고 ?로 원소를 수정하려하기 때문에 오류 발생한다.
const속성을 추가해주는 것은 이 함수를 호출하는 개발자들에게 광고를 하는 효과도 있다.
즉, 함수 원형만 보고도 배열이 수정되지 않겠다는 생각을 하게 된다.

언제 배열의 내용을 보기만 할 수 있게 하고 싶을까?
문자열의 길이를 측정해서 반환하는 함수가 있을 수 있다.
배열 내의 NULL문자를 찾아서 문자열의 길이를 측정하는데 읽기만 할 뿐이다.
이럴 때는 const를 사용해서 쓰기를 할 수 없게 만드는 것이 좋은 습관.

이차원 배열의 전달
14_15.cpp
맨 앞의 대괄호를 비워주어야 한다.
이는 내부적으로 사용하는 포인터의 타입이 '배열에 대한 포인터'인 것과 관련이 있다.
함수의 원형에 적힌 원소의 크기와 일치하지 않는 배열은 함수로 전달할 수 없다.
그 이상 차원의 배열도 맨앞의 대괄호만 비워두면 된다.
void Using3DArray(int arr[][5][10]);

구조체의 전달
기본적인 구조체의 전달
구조체 변수의 크기는 멤버의 개수에 따라서 엄청나게 커질 수가 있다.
그래서 성능 문제를 해결할 수 있는 방법을 주의해서 잘 배워두어야 한다..
14_16.cpp
가상의 코드는
Point p1 = a;
Point p2 = b;
Distance()함수가 시작되면 p1, p2 구조체 생성되고 a, b값으로 초기화 된다.
초기화하는 경우에는 각 멤버의 값을 복사한다.

구조체 타입의 인자와 성능 문제
멤버 값을 모두 복사해야 하므로, 공간적, 시간적 성능 저하를 가져온다.
이를 해결하기 위한 방법으로 배열의 전달 방식에서 발견할 수 있다.
실질적으로는 배열이 아닌 포인터가 사용되었던 것처럼, 구조체의 포인터나 레퍼런스를 전달.
double Distance(Point& p1, Point& p2)
매개 변수의 타입은 '구조체 Point에 대한 레퍼런스'가 된다.
Point& p1 = a;
Point& p2 = b;
더 이상 많은 메모리 공간을 차지하지 않는다.
구조체 대신에 4바이트만 차지하는 레퍼런스를 사용하는 것은 큰 이득.
새로운 구조체 변수가 생기지 않기 때문에, 복사하는 작업도 필요 없다.
하지만, 함수 외부의 a, b의 값을 변경할 수 있는 단점이 생긴다.
읽기만 할 수 있게 만들고 싶을 경우에는 const를 사용해서 보호하자.
double Distance(const Point& p1, const Point& p2)
변경하면 컴퓨터는 오류 메시지를 발생시킨다.
정리해보면
1)구조체를 인자로 넘겨줄 때는 레퍼런스를 사용하자.
2)함수의 안쪽에서 구조체의 내용을 읽기만 한다면 const와 레퍼런스를 사용하자.

일반변수는 const와 레퍼런스를 쓰면안되나요?
물론 일반변수도 가능하지만 일반 변수의 크기는 작기때문에 이득이 없고,
오히려 레퍼런스 변수를 한 번 거쳐서 인자에 접근해야 하기 때문에 손해를 볼 수 있다.

CRT함수의 사용
C Runtime Libray의 약자로 C++언어와 함께 제공되는 라이브러리들. 기본적으로 제공하는 함수들.
sqrt()는 제곱근을 구해주는 함수고 pow()는 거듭제곱을 구해주는 함수다.
double sqrt(double x); //x의 제곱근
double pow(double x, double y); //x^y
14_17.cpp
수학과 관련한 함수를 사용하려면 cmath CRT를 이용.
우리는 sqrt()와 pow()함수의 속이 어떻게 생겼는지 전혀 모른다.
다만 "인자로 무엇을 넘겨주면 어떤 값이 넘겨져 오는지"에 대해서만 알고 있다.
14_18.cpp

*/