/*
01 나머지 복합 타입들
배열, 구조체, 포인터가 복합 타입에 해당했다.

공용체
공용체의 기본
Union은 사용빈도가 그다지 높지 않다.
공용체는 구조체와 비슷하게 생겼지만 모든 멤버가 같은 메모리 공간에 자리잡는다는 특징.
13_1.cpp
모든 멤버는 같은 주소를 갖게되는데, 물론 타입마다 차지하는 크기가 다르다.
공용체의 모든 멤버는 같은 메모리 공간을 사용하기 때문에 공용체 변수의 크기는
가장 큰 크기를 갖는 멤버의 크기와 같게 된다.

열거체
Enumeration은 const의 장점을 보다 효율적으로 누릴 수 있게 해준다.
관련된 심볼들을 한 번에 여러 개씩 정의할 수 있으며, 0,1,2,3..처럼 순서대로 심볼값을 지정.
또한 열거체 자체가 하나의 타입이어서 열거체 타입의 변수를 정의해서 사용하는 것도 가능.
주석이 없다면 코드를 알아보기도 힘들고 고치는데 힘이 든다.
13_2.cpp
자신이 하는 일을 보다 명확하게 보여준다.
인덱스가 2가 아닌 값으로 수정하려면
enum { JOB_DRAWF, JOB_WARRIR, JOB_SORCERER = 3 };
그럼 자동으로 c.jobType이 3인지 비교하는 코드로 바뀐다.
초기화의 여부는 옵션 사항이다.
주의할 점은 심볼의 값이 사용자에 의해서 초기화되면 그 이후 심볼들은 그 값을 기준으로 증가.
enum { JOB_DRAWF, JOB_WARRIR = 3 , JOB_SORCERER };
enum { JOB_DRAWF, JOB_WARRIR = 3, JOB_SORCERER = 4 };
13_3.cpp
JOB_KINDS라는 타입은 JOB_DWARF, JOB_WARRIOR, JOB_SORCERER의 값만 보관할 수 있는 정수타입.

열거자
JOB_DWARF와 같은 심볼 하나 하나를 열거자(Enumerator)나 나열자라고 부른다.

열거체와 정수타입
열거체는 기본적으로 정수 타입이지만 덧셈과 같은 연산을 수행할 수 없다.
enum Color { RED,BLUE,GREEN,SKYBLUE,MAGENTA,YELLOW };
Color color1 = RED;
color1 = SKYBLUE + YELLOW; //에러
정수를 열거체 변수에 대입하는 것도 불가능.
color2 = 5; //에러
하지만 반대의 경우는 가능하다. 열거체 심볼들은 암시적으로 정수 타입으로 형변환된다.
int n = MAGENTA; //가능:MAGENTA가 정수타입으로 형변환.
int m = BLUE +2; //가능:BLUE가 정수 타입으로 형변환.
물론 명시적인 형변환을 사용하면 정수 타입의 값을 열거체 변수에 대입할 수 있다.
Color color3 = (Color)2; //성공:GREEN이 된다.
Color color4 = (Color)50000; //결과를 알 수 없다.
열거체 역시 정수 타입이라는 사실을 기억하자.
결국 열거체 변수에 저장하는 값은 숫자 값이다.
예로 GREEN을 보관했다면 메모리에는 숫자 2가 저장.
범위를 넘어가는 값을 대입하는 경우에는 그 값을 알 수 없다.

열거체의 범위
Color에서 마지막이 YELLOW가 값은 5이다. 하지만 이게 범위는 아니다.
5를 담기 위해서 필요한 최소한의 비트, 이 비트로 표현할 수 있는 최대한의 값이 범위가 된다.
숫자 5를 담기 이ㅜ해서는 최소 3비트가 필요하다. 0 ~ 7. 그래서 0 ~ 7의 범위를 갖는다.
심볼은 음수의 값으로 초기화할 수도 있다.
최소 범위 역시 음수를 보관할 수 있는 최소한의 비트를 구한 후에, 음수의 값을 구하면 된다.

레퍼런스
Reference는 쉽게 말해서 변수의 별명.
변수의 원래 이름 외에 또 다른 이름을 붙여주는 것이 바로 레퍼런스가 하는 일.
int target = 20;
int& ref = target;
지금까지 &는 변수의 주소를 얻을 때 사용했지만, 변수를 정의해주면 레퍼런스 변수를 만들 수.
int는 레퍼런스변수가 참조할 변수의 타입. ref는 레퍼런스 변수의 이름.
target은 레퍼런스 변수가 참조할 변수.
변수 target은 ref라는 새로운 이름을 갖게 된다.
이제 ref에서 값을 읽거나, 변경하는 것은 target에 그렇게 하는 것과 다름 없다.
포인터는 자체적인 메모리 공간을 가지고 있지만, 레퍼런스는 오로지 이름만 존재한다.
13_4.cpp

레퍼런스의 구현
컴퓨터 내부적으로 보았을 때 레퍼런스는 포인터와 같은 방식으로 동작한다.
ref는 target의 주소를 보관하다가 ref에서 값을 읽게 되면 주소로 가서 읽어옴.
하지만, 컴퓨터는 필요에 따라서 정말로 레퍼런스 변수를 위한 메모리 공간을 없앨 수도 있다.
내부적인 동작 방식을 잘 알고 있어야 작성한 코드가 어떤 성능상의 문제점을 가지고 있는지
예상할 수 있을 뿐만 아니라, 디버깅할 때도 많은 도움이 된다.

레퍼런스는 반드시 초기화해야 한다.
float a = 100.0f;
float b = 12.34f;
float& r = a;
r = 200.0f; //a=200.0
r = b; //a=12.34
r = 56.78f; //a=56.78
에서 r에 변수 b를 대입하는 것이지 포인터처럼 별명을 바꾸는 것이 아니다.
레퍼런스 변수를 처음 정의할 때 외에는 다른 변수를 참조하게 만들 수 없다.
처음 지정했으면 죽을 때까지 그것에 대한 별명이 된다.
그러니 처음 초기화를 안하면 다른 변수를 참조하게 만들 수 없다.

레퍼런스는 어떤 타입의 변수라도 참조할 수 있다.

레퍼런스와 const
const 속성을 갖는 레퍼런스 변수는 자신의 값을 변경할 수 없게 된다.
char c = 'A';
const char& r = c;
r = 'B'; //오류
c = 'B'; //성공
이런 특징은 함수와 함께 사용할 때 제 힘을 발휘한다.
const 속성을 가진 레퍼런스는 추가적으로 상수에 대한 별명으로 쓰일 수 있다.
const int& rci = 100; //성공
int& ri = 100; //실패
레퍼런스는 변수를 참조하게 만들어졌기 때문에 상수를 바로 참조할 수 없다.
그래서 이 경우에는 그 상수 값을 갖는 임시 변수(객체)를 하나 만든 후에 레퍼런스가
이 임시 변수(객체)를 참조하게 만든다.
즉, 100의 값을 갖는 임시 변수를 만든 후에 rci가 그 변수를 참조하게 한다.
문제는 이 임시 변수의 값을 변경하는 것이 문제를 유발하기 쉽다.
그래서 const 속성을 가진 레퍼런스만 상수를 참조할 수 있게 허용.
또한, const 속성을 가진 레퍼런스는 다른 타입의 변수를 참조할 수 있다.
char c = 'A';
const int& rci = c; //성공
int& ri = c; //실패
int&타입의 rci가 char타입의 변수 c를 바로 가리킬 수 없기 때문에 컴퓨터는 int타입의
임시 변수를 만들고, c의 값을 int타입으로 형변환해서 임시변수에 넣고 rci가 이
임시 변수를 참조하게 만든다.
만약에 레퍼런스를 통해 변수의 값을 바꿀 수 있더라고, 실제로는 c가 아닌 임시 변수의 값이
바뀌기 때문에 무의미한 일.

typedef
타입에 대한 별명을 만드는 데 사용한다.
1)긴 타입 이름을 짧게 줄여서 쓰는 경우.
2)타입의 의미를 보다 분명하게 해주는 경우.
typedef unsigned char* uc_ptr;
"이제부터 uc_ptr이라고 쓰면 unsigned char*라고 쓴것과 같은 것이다"
3)나중에 타입이 바뀔 수 있는 경우 대비.
나중에 변수의 타입이 int로 변경될 것을 대비해서 
typedef short ID_TYPE; 후에 typedef int ID_TYPE;

02 배열, 구조체, 포인터의 나머지 기능
구조체의 비트 필드
Bit Fields를 사용하면 구조체의 멤버가 차지하는 메모리 공간을 조절할 수 있다.
멤버 a는 3비트만, 멤버 b는 4비트만 차지하게 만들면
struct Flags{
	int a : 3;
	int b : 4;
	bool c : 1;
};
비트 필드를 사용하는 멤버는 정수 타입만 가능. 멤버 뒤에 적힌 숫자가 멤버가 차지할 비트 수.
중간에 사용하지 않는 비트를 넣고 싶을 때는 멤버의 이름을 적어주지 않으면 된다.
struct Flags{
	int a : 3;
	int b : 4;
	int : 5;
	bool c : 1;
};
비트필드는 비트 단위의 논리 연산을 대신해서 사용할 수 있다.
13_5.cpp
convert.us를 통해 저장할 때는 unsigned short타입의 값이었지만,
convert.pixel을 통해서 꺼내 쓸 때는 구조체 Pixel16 타입의 값처럼 사용할 수 있다.
즉, 공용체를 사용하면 동일한 비트의 나열임에도 다른 방식으로 꺼내볼 수 있는것.

비트필드는 보이는 것만큼 효율적일까?
비트 필드를 사용하면 공간도 절약할 수 있고, 비트 단위의 논리연산도 간단하게 수행하지만,
여전히 비트 단위 논리 연산을 사용해서 동일한 작업을 하고 있는것.
그러므로 비트 단위 논리 연산자를 사용하는 것보다 빠르진 않다.
보관하는 데이터들은 더 적은 메모리를 차지하지만, 코드들은 더 많은 메모리를 차지하게 된다.

구조체를 포함하는 구조체
구조체 안에 구조체 변수 정의하기
struct A{
	int i;
	float f;
};
struct B{
	char c;
	A a;
};
점을 여러번 사용해서
B b;
b.a.f = 30.f; 'b의 멤버 a의 멤버 f'처럼 사용.

char 타입이 4바이트?
char 타입의 멤버 c는 4바이트를 차지하게 된다.
각 멤버 사이에 빈공간없이 꽉 붙여서 자리를 잡게 명령할 수도 있고,
4바이트씩 정렬되어서 자리를 잡게 명령할 수도 있다.
여기선 1바이트만 사용하고 나머지 3바이트는 사용하지 않게 된다.
보통은 4바이트가 아니더라도 일정 간격으로 정렬되게 자리 잡는다.
컴퓨터의 내부적인 구조상 이렇게 하는 것이 메모리를 접근하는 속도에서 이득이 되기 때문.
네트워크를 통해서 구조체를 보낼 때는 구조체의 크기를 최대한 줄일 필요가 있다.
이 경우에는 멤버 사이에 빈 공간이 없게 모두 붙여서 자리잡게 만들 수 있다.
비주얼 스튜디오를 사용하면 MSDN에서 '#pragma pack'에 관한 도움말이 있다.
이 명령을 통해서 구조체의 레이아웃을 조정할 수 있다.

구조체의 메모리 저장방식
구조체의 멤버들은 '32비트 CPU'를 기준으로 4바이트씩 할당.
4바이트씩 저장이 되지만 저장방식에서 차이가 있다.
short(2), int(4), char(1), word(2)의 멤버가 있을 경우
ooxx oooo ooox 다음과 같이 채워지게 된다.
그래서 구조체 내부 변수들의 위치를 바꾸게 된다면 구조체의 크기도 변하게 된다.
그래서 자료형을 통일하지 않으면 중간중간 빈공간이 생겨서 메모리 누수가 발생.
해결 방법으로 1바이트씩 단위로 저장하겠다는 것을 명령으로 주면된다.
구조체 작성하기 전에 #pragma pack(1)
하지만 64비트 컴퓨터는 소스를 일일이 찾아서 고춰줘야할 것이다.
그래서 그 문제를 해결하는 방법이 push, pop이다.
#pragma pack(push, 1) //기존 4바이트 정렬 방식을 스택에 저장 후 1바이트로 변경
32비트 기준에선 4바이트씩 일을 처리하는게 가장 빠르기 때문에,
구조체 선언이 끝나는 부분에서 되돌려주지 않으면 성능저하나 오작동이 있을 수 있다.
#pragma pack(pop) //스택에 마지막에 저장된 정렬 방식을 꺼내서 적용(4바이트)

다차원 배열
2차원 배열이란 1차원 배열이 또 길게 늘어선 배열. 차원은 얼마든지 늘어날 수 있다.
배열의 배열인 셈.
int arr[10][5];
이 코드는 10x5 크기의 배열을 만든다.
'int 타입의 원소가 5개 있는 배열'이 10개 있는 배열.
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ -> arr[1]
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
ㅁㅁㅁㅁㅁ
        ㄴ> arr[9][4]
하지만 실제로 2차원 배열은 일렬로 자리를 잡는다.
주소
100 arr[0][0]  ┐
104 arr[0][1]  arr[0]
108 arr[0][2]  │
112 arr[0][3]  ┘
116 arr[1][0]  ┐
120 arr[1][1]  arr[1]
124 arr[1][2]  │
128 arr[1][3]  ┘
132 arr[2][0]
136 arr[2][1]
...
a[7][3]은 7번째 열, 3번째 행에 위치한 원소를 일컫는다.
초기화를 하거나 탐색하려면 중첩된 반복명령을 사용하는 것이 일반적.
for (int i = 0; i < 10; ++i){
	for (int j = 0 ; j < 5; ++j){
		arr[i][j] = 10;
	}
}

포인터를 가리키는 포인터
포인터로 가리킬 수 있는 타입에 제한이 없으므로 포인터를 가리키는 포인터도 만들 수 있다.
char c = '1';
char* pc = &c; //c의 주소값을 가진다
char** ppc = &pc; //pc의 주소값을 가진다.
*ppc는 'ppc가 가리키는 변수'를 의미하므로 pc
**pc는 'ppc가 가리키는 변수가 가리키는 변수'이므로 c를 의미
if (*ppc == pc){
	//실행
}
if (**pc == c){
	//실행
}
예를 들어 c의 위치를 다른 곳에 넘겨주기 위해서는 pc가 필요한데
pc자체가 중요한 '정보'라고 생각해보면 pc의 위치를 알려주기 위해선 ppc가 필요.
포인터의 포인터는 그저 포인터 변수의 주소를 보관하는데 사용할 뿐이다.

*/