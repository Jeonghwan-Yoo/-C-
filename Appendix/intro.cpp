/*
A C++ 보충 학습
전처리기
Preprocessor란 전에 처리하는 것을 말한다.
소스파일에서 샵(#)으로 시작하는 명령들이 전처리기 명령에 속한다.
이들은 컴파일을 시작하기 전에 번역되는 특징이 있다.
#include의 용도는 헤더파일을 포함시키는 것인데, 헤더 파일의 내용을 읽어오는 작업은 컴파일을 하기 전에 이루어진다.
일단 헤더 파일의 내용을 모두 불러온 다음에 컴파일을 시작하는 것이다.
#define:심볼을 정의한다.
#ifdef:심볼을 정의했는지 검사한다.
#else:#ifdef명령이 실패한 경우를 처리한다.
#define NUM 100
int a[NUM];
전처리기에 의해서 소스에서 NUM이라고 써진 부분은 모두 100으로 대체되고 그 다음에 컴파일을 시작하는 것이다.
#define TEST a + b
int main() {
	int a = 10;
	int b = 20;
	int c = TEST;

	return 0;
}
번역된 후에는 다음과 같은 모습을 가진다. 그리고 이 상태에서 컴파일을 시작한다.
int main() {
	int a = 10;
	int b = 20;
	int c = a + b;

	return 0;
}
#define명령을 사용해서 간단한 함수를 만들수도 있다.
#define max(a,b) a > b ? a : b
int c = max(100, 200); //c에 200이 대입 된다.
번역된 모습은
int c = 100 > 200 ? 100 : 200;
실제 함수를 호출하는 것은 아니고 컴파일 시간 이전에 코드가 만들어지는 것이기 때문에 실행 효율이 좋다.
하지만 C++에는 inline함수가 있기 떄문에 #define을 사용해서 함수를 만들필요가 없다.
inline함수 역시 컴파일 시간에 코드를 만들어내기 때문에 실행 효율이 좋을 뿐더러, 인자의 타입검사까지 해줘 보다 안전하다.
C++에서는 const int타입의 변수를 정의함으로써 동일한 일을 할 수 있다.
이 역시 타입을 검사해주는 장점이 있기 때문에 const int를 권장한다.
#ifdef와 #else, #endif는 전처리기의 if라고 생각하면 된다.
#define DEBUG 1
#ifdef DEBUG
int a[100];
a[99] = -1;
#else
int a[10];
a[9] = -1;
#endif
DEBUG라는 이름의 심볼을 정의했는데 뒤에 1은 없으나 있으나 상관없다.
만약 정의했다면 #ifdef을 사용하고 정의하지 않았다면 #else로 간다.
전처리기에 의해서 번역된 코드는
int a[100];
a[99] = -1;
이렇게 두 줄만 남은채로 컴파일되는 것이다.
평소에는 위와 같이 사용하다가, 제품을 출시할 때는 주석처리해서 컴파일하면 나눠서 사용할 수 있다.
//#define DEBUG 1
하지만 너무 과도하게 사용하면 소스가 지저분해지므로 저강히 사용해야 한다.

선언과 정의
//변수를 정의. 실제로 변수를 생성한다.
int a;
//함수의 정의. 실제로 함수를 생성한다.
int Func() {
	return 100;
}
//클래스의 정의. 실제로 클래스를 생성한다.
class Test {
public:
	//멤버 변수의 정의. 실제로 멤버 변수를 생성한다.
	int t;
};
//열거체의 정의. 실제로 열거체를 생성한다.
enum {
	LEFT, MIDDLE, RIGHT
};
정의의 특징은 실제로 그 대상체를 생성한다는 점이다.
//변수의 선언. 다른 곳에 정의한 변수를 소개한다.
extern int a;
//함수의 선언. 다른 곳에서 정의한 함수를 소개한다.
int Func();
//클래스의 선언. 다른 곳에서 정의한 클래스를 소개한다.
class Test;
선언에 의해서 어떤 대상체가 생성되지는 않는다.
선언은 이미 다른곳에서 정의한 대상체를 단순히 가져다 사용하기 위한 목적으로 사용한다.
C++에서 정의는 단 한번만할 수 있다는 규칙이 있다. 두 번 정의하면 오류가 발생한다.
하지만 선언은 얼마든지 많이 할 수 있다.
정의는 실제로 변수가 생기는 것이지만, 선언은 그저 변수의 이름을 소개하는 것에 지나지 않기 때문이다.

B 타입의 범위
B_1.cpp
괄호는 타입이 차지하는 바이트 수를 의미한다.
char의 경우에는 -128~127, 0~255의 최대값 최소값이 문자로 출력된 것이다.

비주얼 C++6.0 사용자의 경우
올바르게 동작하지 않을 수 있는데, 함수 템플릿을 완벽하게 지원하지 않기 때문이다.
void ShowRange(const char* typeName, T t=0)이라고 수정하자.

C 연산자 우선 순위
위쪽에 있는 연산자일수록 우선 순위가 높다. 같은 그룹에 포함된 연산자라면 위치에 상관없이 동일한 우선 순위.
결합 순서가 빈칸인 경우는 바로 위쪽의 연산자와 결합 순서가 같다.
int i = a << 3 + b >> 2;
덧셈 연산자가 쉬프트 연산자보다 앞에 있기 때문에 덧셈 연산을 가장 먼저 수행한다.
int i = a << (3 + b) >> 2;
<<와 >>는 같은 그룹에 있기 때문에 같은 우선 순위. 이럴 때는 결합 순서를 봐야하는데 왼쪽부터 결합이다.
int i = (a << (3 + b)) >> 2;
연산자              설명                                   결합 순서
::                 영역 지정                               X
()                 수식을 묶어주는 괄호                     X
()                 함수 호출을 위한 괄호                    왼쪽부터
()                 임시 객체 생성에 사용하는 괄호            왼쪽부터
[]                 배열의 원소 지정                         왼쪽부터      
->                 멤버 지정                                왼쪽부터
.                  멤버 지정                                왼쪽부터
const_cast         형변환                                   왼쪽부터
dynamic_cast       형변환                                   왼쪽부터
reinterpret_cast   형변환                                   왼쪽부터
static_cast        형변환                                   왼쪽부터
++                 1증가 후치연산                            왼쪽부터
--                 1감소 후치연산                            왼쪽부터
!                  논리 NOT 연산                            오른쪽부터
~                  비트 단위 NOT연산                        오른쪽부터
+                  양수 기호(Unary)                         오른쪽부터
-                  음수 기호(Unary)                         오른쪽부터
++                 1증가 전치연산                            오른쪽부터
--                 1감소 전치연산                            오른쪽부터
&                  주소구하기                                오른쪽부터
*                  포인터가 가리키는 곳                       오른쪽부터
()                 형변환에 사용하는 괄호                     오른쪽부터
sizeof             타입, 변수의 크기 구하기                   오른쪽부터
new                동적메모리할당                            오른쪽부터
new[]              동적메모리할당                            오른쪽부터
delete             동적메모리해제                            오른쪽부터
delete[]           동적메모리해제                            오른쪽부터
.*                 멤버가 가리키는 곳                        왼쪽부터
->                 멤버가 가리키는 곳                        왼쪽부터
*                  곱셈                                     왼쪽부터
/                  나눗셈                                    왼쪽부터
%                  나머지                                    왼쪽부터
+                  덧셈(Binary)                              왼쪽부터
-                  뺄셈(Binary)                              왼쪽부터
<<                 왼쪽으로 쉬프트                            왼쪽부터
>>                 오른쪽으로 쉬프트                          왼쪽부터
<                  관계연산                                   왼쪽부터
<=                 관계연산                                   왼쪽부터
>=                 관계연산                                   왼쪽부터
>                  관계연산                                   왼쪽부터
==                 관계연산                                   왼쪽부터
!=                 관계연산                                   왼쪽부터
&                  비트단위 AND연산                           왼쪽부터
^                  비트단위 XOR연산                           왼쪽부터
|                  비트단위 OR연산                            왼쪽부터
&&                 논리 AND연산                               왼쪽부터
||                 논리 OR연산                                왼쪽부터
=                  대입                                       오른쪽부터
*=                 축약형                                     오른쪽부터
/=                 축약형                                     오른쪽부터
%=                 축약형                                     오른쪽부터
+=                 축약형                                     오른쪽부터
-=                 축약형                                     오른쪽부터
&=                 축약형                                     오른쪽부터
^=                 축약형                                     오른쪽부터
|=                 축약형                                     오른쪽부터
<<=                축약형                                     오른쪽부터
>>=                축약형                                     오른쪽부터
:?                 삼항 연산                                  오른쪽부터
throw              예외던짐                                   왼쪽부터
,                  수식을 하나로 합침                          왼쪽부터

D 아스키 코드
모든 정보는 숫자로 이루어져 있다.
문서 역시 컴퓨터 내부적으로는 숫자로 보관되는데, 이때 문자와 숫자를 매칭시키는 규칙 중에 하나가 아스키 코드.
키보드에서 Alt키를 누른 상태에서 키패드에서 아스키코드를 누르면 해당하는 문자가 화면에 출력된다.
아스키코드는 7비트만을 사용한다.
특수문자들에도 이름들이 붙어있다.
^는 ctrl키를 의미한다.
A는 '65', a는 '97', 0은 '48'

*/