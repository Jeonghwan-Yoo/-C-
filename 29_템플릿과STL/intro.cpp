/*
01 템플릿
템플릿을 사용하면 컴퓨터가 대신 클래스나 함수를 만들어내게 할 수가 있다.
그리고 C++에는 이러한 템플릿을 사용해서 만들어진 다양한 클래스와 함수들을 STL이라는 이름으로 제공하고 있다.

왜 템플릿을 사용해야 할까
오직 C++에만 있는 독특한 기능.
탬플릿을 사용하면 단순한 코딩 작업을 컴퓨터에게 맡길 수가 있다.
int max(int a, int b) {
	return (a > b ? a : b);
}
float타입의 두 값을 비교하려면 오버로딩을 할 수도 있겠지만 코드를 좀만 수정하면 C++에 존재하는 모든 기본타입은 물론이고
클래스 타입까지도 인자로 받을 수 있는 max()함수가 만들어진다.
컴퓨터가 우리를 위해 만들어 주는 것.
템플릿은 함수를 자동으로 생성하는 것에 더해서 클래스까지 자동으로 생성해줄 수 있다.
구분하기 위해 템플릿 클랫, 템플릿 함수 등으로 나누어 부른다.
편하게 해주는 것만 있는 것이 아니라 결과적으로 템플릿을 사용해서 작성한 코드는 사용안한 코드보다 더욱 훌륭하다.

템플릿 클래스
int 타입의 배열을 담아서 사용할 수 있는 스마트 포인터 클래스다.
내부적으로 배열의 주소를 보관하고 있다가 소멸자에서 배열을 해제하는 아주 기본적인 기능
29_1.cpp
AutoArray클래스는 int타입의 배열만을 관리할 수 있다.
만약 double타입이나 다른 배열을 관리할 수 있는 스마트 포인터 클래스가 필요해진다면 여러개 만들어야 하는데
또 다른 클래스를 만들어야 하는 작업시간도 문제지만 가장 큰 문제는 같은 내용의 소스 코드가 중복된다는 점이다.
다루는 배열의 타입이 다를뿐 그 클래스들이 하는 일은 모두 동일한 것이기 때문.
이럴 때 AutoArray를 템플릿 클래스로 만드는 일이다.
AutoArray클래스에 약간의 수정을 가하면 모든 타입의 배열을 관리할 수 있는 스마트 포인터로 거듭날 수 있다.
29_2.cpp
무엇이 될지 모르는 타입을 T와 같은 변수로 두고 T를 기준으로 템플릿 클래스를 작성하는 것이다.
그리고 템플릿 클래스를 사용할 때 T대신에 구체적인 타입을 명시해준다.
AutoArray<float>와 같이 사용하게 되면 그제서야 컴퓨터는 T대신에 float를 넣어서 새로운 클래스를 만들게 된다.
컴퓨터에게 T대신에 float를 넣어서 새로운 클래스를 만들게 시킨 셈이다.
만들어진 소스가 눈에 보이는 것 은 아니지만 컴퓨터 내부적으로는 그 클래스가 존재하고 있다.
T를 템플릿 매개변수(Template Parameter)라고 부른다. 매개변수는 얼마든지 많이 올 수 있다.

서로 다른 타입의 배열 두 개를 보관할 수 있는 템플릿 클래스
29_3
template<typename A, typename B, int MAX>
class TwoArray {
	A arr1[MAX];
	B arr2[MAX];
};
TwoArray<char, double, 20> arr;
컴퓨터는 이 코드를 보고 내부적으로 다음과 같은 클래스를 하나 만들게 된다.
class TwoArray_char_double_20 {
	char arr1[20];
	double arr2[20];
};
A,B,MAX라고 적혀있던 부분이 char, double, 20으로 바뀐다.
typename대신에 class라고 적을수도 있다. 어느 것을 사용하던 아무런 차이가 없다.

아주 간단한 작업만 해주면 컴퓨터가 알아서 필요한 클래스들을 모두 만들어주는 것이다.

템플릿 함수
모든 타입에 대해서 사용할 수 있는 max()함수
29_5.cpp
템플릿 클래스에서 배운 것이라면 max<int>(i1,i2)라고 사용해야 하지만, 함수의 경우에는 타입을 명시하지 않고 사용하는 것이 가능.
왜냐하면 입력하는 인자의 타입을 통해서 T대신에 어떤 타입을 대입해야 하는지 유추할 수 있기 때문이다.
멤버 함수 역시 템플릿 함수로 만들 수 있다.
템플릿 클래스가 아닌 클래스의 멤버 함수일지라도 템플릿으로 만드는 것이 가능하다.

템플릿 함수를 구현 파일에 놓을 수 있다?
템플릿 함수의 정의를 헤더 파일에 놓게 되면 소스 코드가 지저분해지기 쉽다.
그래서 C++는 템플릿 함수의 정의를 구현 파일에 놓을 수 있게 export라는 키워드를 제공한다.
템플릿 함수의 정의를 구현 파일에 놓고 그 앞에 export라는 키워드를 붙여주면 되는 것이다.
하지만 export키워드를 지원하지 않는 컴파일러에게 하면 바르게 동작하지 않을 수 있다.

템플릿 사용시 유의할 점
클래스나 함수자체를 만들어 내기 때문에 기존기능과 다르다.

1)탬플릿은 컴파일 시간에 코드를 만들어낸다.
컴파일 시간이란 소스 코드를 컴파일하고 있는 그 순간을 의미하며 
실행 시간이란 컴파일한 프로그램이 실제로 컴퓨터 상에서 실행되고 있는 순간을 의미한다.
"템플릿은 프로그램이 실행되는 도중이 아니라, 소스코드를 컴파일하는 도중에 클래스나 함수를 만들어 낸다"
템플릿이 새로운 클래스나 함수를 만드는 동작을 컴파일 시간에 수행한다는 것은 중요한 의미가 있다.
실행되는 도중에 만들게 되면 프로그램의 실행 속도가 느려지기 때문이다.
하지만 실행되기 전에 미리 만들어져 있기 때문에 템플릿을 많이 사용하더라도 프로그램이 느려지는 일은 없다.
대신에 컴파일하는 도중에 클래스나 함수를 생성해야 하므로 컴파일이 오래걸리는 단점이 생기기는 한다.
하지만 매번 실행할 때마다 느려지는 것보다 컴파일할 때 한 번만 느려지는 게 훨씬 낫다.

2)템플릿 함수의 정의는 헤더 파일에 놓여야 한다.
소스코드가 여러 파일로 이루어져 있는 경우에 함수의 정의를 구현 파일에 놓는 것이 일반적이다.
만약에 함수의 정의를 헤더 파일에 놓게 되면 그 헤더 파일을 포함하는 다른 여러 구현 파일에서 중복 정의되는 결과를 가져오므로.
하지만 템플릿 함수는 반드시 헤더 파일에 놓여야 한다.
실제로 함수를 정의하는 의미라기보다는 컴퓨터에게 함수를 만드는 방법을 가르쳐주는 의미를 갖기 때문에 예외적인 규칙.
템플릿 함수란 일반 함수와 멤버함수 모두를 가리킨다.
또한 템플릿 클래스의 일반 멤버 함수도 포함되는 말이다.
템플릿 클래스의 멤버 함수는 템플릿 함수가 아니더라도 헤더 파일에 위치해야 한다.

02 STL
왜 STL을 사용해야 할까?
STL(Standard Template Library)에는 자주 사용하게 될 유용한 클래스와 함수들이 들어있다.
STL은 템플릿을 사용해서 만들어진 라이브러리다. 클래스와 함수들의 모임.
링크드 리스트클래스, 동적 배열 클래스, 정렬함수, 검색 함수 등과 같이 범용적인 클래스와 함수들이 있다.
템플릿으로 만들어져 있기 때문에 확장이 용이하다.
즉, STL의 링크드 리스트를 사용해서 우리가 만든 클래스 객체를 보관하는 등의 일을 간단하게 할 수 있다.
또한 STL은 표준이다. 어디든 똑같은 클래스와 함수를 사용한다.
그러므로 상대방이 작성해놓은 코드를 쉽게 알아볼 수 있다.
또한, 전문가들이 만들어 놓은 것이어서 효율적이고 안전하다.
그런것들을 더 잘만드는 노력을 하는 것보다 생산성있는 다른 일을 하면 더 유익알 것 같다.
만들어봄으로써 C++을 배우는데에는 더 좋다.

STL컨테이너
컨테이너(Container)란 다수의 정보를 담는 역할을 하는 클래스를 말한다.
보통 링크드 리스트나 동적인 배열, 큐나 맵 등의 클래스들을 컨테이너라고 부른다.
STL의 모든 컨테이너들은 거의 유사한 사용법을 가지고 있다.

list 클래스 사용하기
list객체를 만들고 노드를 추가하는 등의 작업을 수행한다.
29_6.cpp
std::list<int>::iterator it;
iterator클래스의 객체인 it을 생성하고 있다.
iterator클래스가 노드의 위치를 가리키는 역할을 한다.
즉, iterator 객체 it를 사용해서 첫번째 노드부터 마지막 노드까지 반복적으로 가리키는 것.
마지막 노드 intList.end()는 아무런 값이 없다.
intList.begin()은 첫번째 노드의 위치를 반환하는 멤버 함수다.
intList.end()은 마지막 노드의 위치를 반환하는 멤버 함수다.
++it에 의해 it은 다음 노드를 가리키게 된다. 포인터에 ++p와 같다.
intList.end()가 가리키고 있는 노드는 9값을 가진 노드의 다음 노드이다. 아무런 값이 없다.
포인터를 흉내내기위해 *와 ++를 오버로딩했다.

우리가 만든 링크드 리스트보다 좋은점
우리가 만들었던 링크드 리스트 클래스는 모든 타입을 담기 위해서 void*타입을 사용했기 때문에
노드에 보관한 정보를 제거하는 데 있어서 문제가 있었다.
그 문제를 해결하기 위해서 함수 포인터를 쓰는 등 복잡한 구조가 되었고, 사용하는 것도 복잡해졌다.
하지만 list클래스같은 경우에는 그런 문제가 없다.

자주 사용하는 STL의 컨테이너 클래스
vector:동적인 배열, 동적으로 원소의 개수를 조절할 수 있는 배열이다.
list:링크드 리스트.
deque:배열과 링크드 리스트의 장점을 모아놓은 컨테이너. 배열만큼 원소에 접근하는 시간이 빠른 동시에 맨 앞과 끝에
원소를 추가하고 제거하는 시간은 링크드 리스트만큼 빠르다.
map:원소를 가리키는 인덱스까지도 다양한 타입을 사용할 수 있다. 문자열 타입의 인덱스를 사용할 수도 있다.
map<string, string> m;
m["add"] "더하다.";
이런 컨테이너 클래스들이 모두 유사한 인터페이스를 가진다.
STL의 철학은 최소한의 소스 수정으로 컨테이너를 다른 것으로 교체할 수 있다.
노드에 빨리 접근하는 것이 중요한 프로그램이면 vector클래스를 사용하는 것이 좋다.
배열이 링크드 리스트보다 노드에 대한 접근 속도가 빠르기 때문이다.
만약 노드의 추가나 삭제가 빈번하게 일어난다면 list클래스를 사용하면 좋다.
링크드 리스트는 노드를 추가하고 제거하는 속도가 배열보다 훨씬 빠르기 때문이다.
이런 특징은 프로그램의 개발이나 유지보수 시간을 단축하는데 큰 도움이 된다.

STL알고리즘
STL에서 제공하는 함수들을 의미한다.
정렬(Sorting)이나 검색(Searching)과 같은 알고리즘을 구현해 놓은 함수들.
vector클래스와 일반적인 배열을 사용해서 동일한 방법으로 sort()함수를 사용할 수 있다.
29_7.cpp
배열의 첫번째 원소와 마지막 원소의 위치만 넘겨주면 sort()함수가 알아서 정렬해준다.
vector클래스와 list클래스의 사용법은 거의 비슷하고, 일반적인 배열까지도 STL컨테이너와 유사한 방식으로 다룰수 있었다.
정보를 담는 컨테이너와 정보를 처리하는 알고리즘이 서로 독립적이다.
그렇기 때문에 sort()함수는 어떤 컨테이너에 특화된 것이 아니라 모든 컨테이너를 다룰 수 있게 범용적으로 만들어졌다.

유용한 알고리즘들
find():선형 검색 알고리즘. 첫번째 원소부터 하나씩 비교해보는 방법이다.
replace():특정한 값을 가진 우너소를 찾아서 다른 값으로 교체한다.
reverse():원소들의 순서를 거꾸로 뒤집는다.
sort():오름차순으로 정렬한다.
binary_search():이진탐색 알고리즘. 원소들이 정렬되어 있는 경우에 사용할 수 있는 탐색 방법이다.

list클래스는 sort()함수를 사용할 수 없다?
sort()함수는 어떤 컨테이너라도 다룰 수 있게 구현되어 있지만 컨테이너마다 물리적인 차이점 때문에 리스트는 불가능하다.
list클래스는 링크드 리스트라는 특징때문에 a[2]처럼 직접적으로 노드에 접근할 수가 없다.
'헤드 노드의 다음 다음 노드'이런 식으로 접근해야 한다.
STL컨테이너들은 거의 동일한 인터페이스를 가지고 있지만 이런 물리적인 제약으로 약간의 차이를 가지고 있다.
이런 경우 컨테이너에 특화된 알고리즘 함수를 사용할 수가 있는데, list클래스는 특화된 sort()함수를 멤버함수로 가지고 있다.

제너릭 프로그래밍
Generic Programming은 객체지향 프로그래밍처럼 프로그램을 만드는 방법론 중 하나이다.
가장 중요하게 생각하는 것은 정보의 타입과 정보를 처리하는 알고리즘을 분리하는 것이다.
STL의 컨테이너 클래스들와 알고리즘 함수들은 제너릭 프로그래밍을 적용한 예이다.
컨테이너들을 '정보의 타입', sort()함수를 비롯한 알고리즘 함수들을 '정보를 처리하는 알고리즘'.
분리하게 되면 여러 장점을 갖게 되는데
1)타입과 알고리즘간의 불필요한 연관성이 제거(Decoupling)되는 점.
vector클래스의 구현을 변경해도 sort()함수는 영향을 받지 않는다. 반대도 같은 상황.
2)연관성이 제거되면 자동적으로 재사용성(Reusability)가 증가하게 된다.
같이 사용할 필요가 없기 때문에 sort()함수만 가져다가 다른 컨테이너와 사용하는 등의 재사용이 용이해진다.
컨테이너마다 sort()를 만들면 새로 만들어서 불필요한 코드의 중복이 발생할 것이다.
3)확장이 용이하다.
begin(), end()와 같은 공통적인 인터페이스를 유지하고 있다.
새로운 컨테이너 클래스를 만들 때 이 공통의 인터페이스를 유지하기만 해도 STL의 모든 알고리즘을 사용할 수 있게 된다.
알고리즘 함수를 새로 만들 때에도 STL의 모든 컨테이너를 사용할 수 있게 된다.

STL을 사용하지 않더라도 프로젝트에 제너릭 프로그래밍의 철학을 적용할 수가 있다.
템플릿을 사용하면 모든 타입을 다룰 수 있는 코드를 손쉽게 작성할 수 있고, 
타입과 알고리즘을 분리시키는 작업을 간단하게 만들어 준다.
제너릭 프로그래밍은 재사용성이 높고 불필요한 중복이 없는 간결한 코드를 만드는 데 중요한 역할을 한다.
템플릿은 컴파일 시간에 코드를 생성하기 때문에 실행 효율 또한 좋다.

다형성
다형성을 사용해도 타입과 알고리즘을 분리할 수 있다.
같은 부모를 가진 타입이라면 실제 객체 타입에 상관 없이 동일하게 다룰 수 있기 때문이다.
하지만 탬플릿을 사용한 경우가 조금 더 빠르게 실행된다.
가상 함수를 사용하는 경우에는 어떤 클래스의 함수를 호출해야 하는지 계산하는 시간을 소모하지만,
템플릿은 컴파일 시간에 미리 계산해서 코드를 만들어 주는 것이기 때문이다.
하지만 템플릿을 사용하면 컴퓨터가 만들어낸 코드가 많아지기 때문에 프로그램의 크기가 커지는 단점이 있다.
또한, 디버깅 시에 조금 더 복잡한 경향이 있다.

*/