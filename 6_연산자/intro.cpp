/*
01 기본적인 연산자
왜 연산자를 사용해야 할까
입력된 정보를 처리해서 원하는 정보를 출력하기 위해 정보를 가공해야 해서.

아주 기본적인 사칙 연산
6_1.cpp
a와 b처럼 연산자의 입력으로 들어가는 값 혹은 변수를 피연산자(operand)라고 부른다.
연산자는 피연산자를 사용해서 자신만의 고유한 연산을 수행하고 연산 결과를 내놓는다.
그리고 한 연산의 결과는 다른 연산의 피연산자가 될 수 있다. 연쇄적으로 적용.

대입연산자(Assignment Operator)
변수에 값을 대입할 때 사용하는 '='을 의미한다.
두 개의 피연산자를 받고, 우측 피연산자의 값을 좌측에 대입한다.
대입 연산자는 '대입한 값'을 결과로 반환한다.
6_2.cpp
제일 먼저 'c=100'을 수행하고 100을 반환하고 'b=100'을 수행.

관계 연산자(Relational Operators)
정보의 상태를 검사하는 데 사용한다.
비교할 줄 알아야 하고 비교 결과에 따른 행동을 취할 수 있어야 한다.
6_3.cpp

연산자 우선 순위
연산자에는 Operator Precedence라는 것이 존재. 우선 순위가 높은 연산자를 우선적으로 계산.
관계 연산자는 대입 연산보다 높은 우선 순위.
괄호 안의 수식은 먼저 계산.

논리 연산자
Logical Operators는 조건을 만드는데 사용한다. &&, ||, !

AND(&&), OR(||)연산자
AND연산은 두 개의 bool 타입 피연산자를 취하고 모두 true인 경우에만 true를 반환.
6_4.cpp
피연산자의 위치에는 관계 연산이 들어가는 것이 보통.
6_5.cpp
연산자 우선 순위에 의해 >와 ==를 먼저 계산.
OR연산도 두 개의 bool 타입 값을 피연산자로 받는다. 보통 관계 연산의 결과를.
둘 중 하나의 피연산자만 true여도 true를 반환한다. either가 아님.
&&연산자는 ||보다 우선순위가 높기 때문에 주의할 필요가 있다.
6_6.cpp
괄호를 사용해서 정리해주는 것이 가독성 면에서 좋다.

NOT(!)연산자
하나의 피연산자만을 받는데, true라면 false, false라면 true를 반환.
6_7.cpp
보통 관계 연산과 함께 사용되는 것이 일반적.
드모르간 이용하면 (A&&B)==!(!A||!B)

&&와||는 앞의 피연산자를 보고 먼저 판단하기 때문에 예로
(a > b) && (b = 10); 같은 코드에서 두 번째는 계산하지도 않는다.

02 비트 단위 연산
비트 단위 연산자
Bitwise Operators는 비트의 수준에서 정보를 조작할 수 있게 해준다.
화상이나 음성, 압축한 정보들을 다룰 때 요긴한 기능.
정보를 쪼개면 비트 수준까지 내려가서 정보가 보관되기 때문에 해당 비트만 바꾸는 작업을 해야한다.
컴퓨터의 내부 구조를 구체적으로 이해할 수 있고, 디버깅 등에서 아주 유용하게 활용.

2진수, 10진수, 16진수
비트는 2진수로 표현. 실제 프로그래밍에서는 변환이 용이한 16진수를 많이 사용.
서로의 변환방법을 알고 있으면 좋다.
2진수<->16진수는 16진수는 2진수가 4개 합쳐져있는거라고 생각하면 된다.
2진수<->10진수는 2의 배수를 이용하거나 나누어서 나머지를 나열해 구함.
4개의 2진수를 의미하는 16진수 한 자리를 '니블(Nibble)'이라고 한다.

정수값을 2진수로 출력하려면 bitset클래스를 이용해야한다.
char는 8비트, short int는 16비트.
6_8.cpp

비트 단위 논리 연산자
Logical Bitwise Operators는 한 비트를 대상으로 논리 연산을 수행한다.
피연산자의 각 비트에 대해서 논리 연산을 수행하면 된다. &(AND),|(OR), ~(NOT), ^(XOR)
XOR은 두 피연산자가 같으면 0 다르면 1을 반환.
피연산자들은 보통 정수 타입의 값. 32비트 정수라면 32번의 논리 연산을 수행.
6_9.cpp

비트 단위 논리 연산의 응용
윈도우즈 운영체제의 16비트 칼라(트루칼라)는 점 하나를 표시하는데 16비트를 사용한다는 뜻.
16비트가 표현할 수 있는 상태의 수 만큼이나 다양한 색상을 표현할 수 있다.
컴퓨터 사에서 색상을 표현할 때는 보통 빛의 3요소 Red, Green, Blue RGB를 기본요소로.
16비트면 R과B는 5비트 G는 6비트.
6_10.cpp
AND연산자를 이용해 0x001f를 필터와 같은 역할로. '마스킹(masking)'이라고 부르기도 한다.

쉬프트 연산자
Shift Operation은 비트를 몇 칸씩 옆으로 이동하는 연산을 말한다.
6_11.cpp
왼쪽에 새롭게 채워지는 비트들을 0의 값을 갖게 된다.

빨간색의 밝기를 30으로 바꿔주려면
6_12.cpp
왼쪽으로 쉬프트하는 경우에도 오른쪽에 새로 채워지는 비트 값은 0이다.

컴퓨터는 cout << 과 쉬프트 <<를 구분할 수 있을까?
<<왼쪽에 cout객체가 있다면 화면에 출력하라는 의미, 정수가 있으면 쉬프트하라는 의미.
C++에서는 연산자 오버로딩의 기능을 지원하면서 연산자의 용도를 확장할 수 있다.

부호가 있는 값의 쉬프트
단순하게 비트들을 옮기고 0으로 채우는 쉬프트가 있는 반면에 값의 부호를 유지하면서
비트들을 옮기는 쉬프트가 있다.
6_13.cpp
unsigned short 타입의 경우에는 새로 추가하는 비트의 값이 0인 반면에 signed short 타입의
경우에는 1의 값으로 설정한다.
컴퓨터가 부호를 유지하기 위해서 노력하기 때문.
즉, 음수의 값을 오른쪽으로 쉬프트할 때만 1로 채워진다.

쉬프트 연산은 빠른 곱하기다?
정의는 비트를 이동하는 것이지만, 곱하기 혹은 나누기를 대신할 수 있습니다.
왼쪽으로 n 쉬프트하면 곱하기 2^n한 것과 같은 효과.
오른쪽으로 쉬프트하는 경우에는 2^n으로 나눈 효과.
곱하기나 나누기를 직접 사용하는 것보다 쉬프트 연산의 속도가 빠르다.
그래서 게임 프로그래밍과 같은 연산 속도가 중요한 곳에서는 쉬프트 연산을 대신 사용.

03 연산자 더 잘 알기
연산자의 축약형
a+=b; == a=a+b; 모든 연산자의 적용 가능.
특별히 변수의 값을 1증가시키는 ++와 --가 있다.
6_14.cpp
첫째줄은 연산을 하고 난 후의 값이고 둘째줄은 연산의 결과를 대입한 변수들의 값.
전치 연산은 변수의 값을 증가 혹은 감소한 후에 결과를 반환.
후치 연산은 현재 변수의 값을 결과로써 반환한 후에 증가 혹은 감소한다.

연산 중에 발생하는 형변환
long과 float을 계산하면 long타입의 피연산자가 float타입으로 형변환 후에 연산 실행.
피연산자의 타입이 동일하지 않은 경우에 형변환을 통해서 타입을 일치하는 규칙.
두 피연산자 중에서 보다 큰 타입쪽으로 형변환이 발생.
long double > double > float > unsigned long > long > unsigned int > int.
int보다 작은 타입(char, short...)은 정수형 승진(integral promotion)이라는 과정을 통해
int나 unsigned int로 형변환되서 순서에 존재하지는 않는다.
즉, 연산 중에 발생하는 형변환은 피연산자의 타입에만 영향을 받는다.
6_15.cpp
형변환은 오직 피연산자의 타입에만 영향을 받고, 
결과를 받는 변수의 타입은 아무런 영향을 받지 않는다.

*/