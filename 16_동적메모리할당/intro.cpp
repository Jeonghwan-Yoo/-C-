/*
01 동적 메모리 할당의 기본
Dynamic Memory Allocation은 메모리를 다루는 또 다른 방법.

왜 동적 메모리 할당을 사용해야 할까
동적 메모리 할당의 개념 이해하기
말 그대로 메모리를 동적으로 할당한다는 뜻.
메모리 할당은 쉽게 말해서 컴퓨터로부터 메모리를 얻어오는 일.
변수를 정의하는 것은 정적 메모리 할당.
동적 메모리 할당은 메모리의 크기를 지정해줄 때 변수를 사용할 수 있다.
int* p;
int length;
cin >> length;
p = new int [length];
메모리의 크기를 length라는 변수를 사용해서 지정해주었다.
length는 프로그램을 시작하고 나서 사용자가 입력해준 값.
즉, 메모리의 크기가 프로그램이 실행되는 도중에 동적으로 결정될 수 있다.
1)프로그램을 실행하기 전에 할당할 메모리의 크기가 결정되면 정적인 메모리 할당.
프로그램을 실행하고 나서야 할당할 메모리의 크기가 결정되면 동적인 메모리 할당.
2)동적인 메모리를 할당하고 해제하는 시점이 자유롭다는 것이다.
변수를 정의한 문장을 만나면, 변수에게 필요한 만큼의 메모리를 할당한다.
함수의 실행이 끝나면 자동적으로 메모리가 해제되고, 변수도 소멸.
동적 메모리는 할당하는 시점도 맘대로, 해제하는 시점도 맘대로 정할 수 있다.

배열은 변수를 사용해서 크기를 지정할 수 없나요?
원소의 개수를 지정할 때는 오직 상수만 사용할 수 있습니다.
int length = 100;
int arr[length]; //오류

메모리의 해제
메모리를 확보하는 과정을 할당이라고 부르면 반납하는 과정을 해제(free)라고 한다.

동적 메모리 할당을 어디에 쓸 수 있을까
입력 받은 숫자들의 평균을 구하는 프로그램에서 배열의 크기를 지정해주면
그거보다 커지면 더이상 할 수가 없고 작으면 메모리 낭비이다. 이런 경우에 해주면 좋다.
사용자가 몇 개의 숫자를 입력할 것인지 알려주면, 그 만큼의 메모리를 동적으로 할당하는 것이다.
사용자가 원하는 만큼, 충분하고도 낭비없는 메모리 할당.

그림 파일을 읽어서 화면에 보여주는 프로그램이라고 해보자
void* ReadImageFile(){
	1. 그림 파일을 연다.
	2. 그림 파일의 크기를 알아낸다.
	3. 그 크기 만큼의 메모리를 할당한다.
	4. 그림 파일의 내용을 읽어서 메모리로 복사한다.
	5. 그림 파일을 닫는다.
	6. 이 함수를 호출한 함수에게 메모리를 넘겨준다.
}
실행 도중에 크기를 결정하고 메모리를 할당할 수 있다.
동적으로 메모리를 할당한 경우에만 함수 밖으로 메모리를 전달할 수 있다.
동적으로 할당한 메모리는 함수가 종료하더라도 계속 존재한다.
그러나 배열과 같은 정적으로 할당한 메모리는 함수의 종료와 함께 소멸.

기본적인 동적 메모리 할당과 해제
입력한 정수 값들의 평균을 구하는 프로그램
16_1.cpp
int* arr = new int [size];
int타입의 값을 size개수 만큼 보관할 수 있는 크기의 메모리를 할당하고, 반환하는 주소 값으로
arr을 초기화 한다. 즉, 할당한 메모리 주소를 대입한다.
일반적으로 동적으로 할당된 메모리가 있는 곳은 보통의 변수가 사는 곳과 떨어져 있다.
delete[] arr;
해제시킬 메모리의 주소를 지정하고, 가리키는 곳의 메모리를 해제시킨다.

메모리 할당한하고 대입하지 않을 수도 있나요?
new int [10];
코드 상은 문제가 없지만 그 주소 값을 보관하지 않아서 주소를 알아낼 방법이 없다.

정리해보면
1)메모리를 할당할 때는 타입과 크기를 지정한다. 컴퓨터가 메모리를 할당한 후에 메모리의
주소값을 반환한다. 그리고 이 주소를 보관해두어야 한다.
2)보관해둔 주소를 통해 메모리 공간을 사용할 수 있다. 배열의 원소를 가리키는 포인터처럼 사용.
3)사용이 끝난 후에는 반드시 보관해둔 주소를 알려주면서 메모리를 해제한다.

해제할 때는 크기를 알려주지 않아도 되나요?
메모리의 주소 값만 알려주면 된다. 컴퓨터는 내부적으로 그 정보를 보관하고 있다.

연산자 new, delete, new[], delete[]
new, delete는 변수 하나를 동적으로 할당하는 것이고
new[], delete[]는 배열을 동적으로 할당하는 것이라고 할 수 있다.
16_2.cpp
p는 보통의 변수를 가리키는 포인터처럼 사용하면 된다. 메모리 구조가 동일.
new, delete는 기본 타입을 할당하는데 사용하지 않는다. 굳이.
new, delete는 구조체와 같은 복합 타입과 뒤에서 배울 클래스에 관련해서 빈번하게 사용.
구조체나 클래스는 변수 하나의 크기가 클 수 있기 때문.

원소가 1개인 int타입의 배열을 할당한 경우와 무엇이 다른가요?
차이는 없지만 new, delete, new[], delete[]는 꼭 짝을 맞추어 사용해야 한다.

동적 메모리 할당과 관련된 기본 규칙
new, delete와 new[], delete[] 쌍을 맞춰서 사용하자.
new로 할당한 메모리를 delete[]로 해제하려고 하면 있지도 않은 배열을 해제하려고해서 문제.
반대의 경우는 할당된 메모리의 일부분만 해제될 수 있다.

NULL 포인터를 해제하는 것은 안전하다.
char* p = NULL;
delete p; //혹은 delete[] p
메모리의 주소값으로 NULL이 넘겨져 온 경우에는 delete, delete[]가 아무일도 하지 않는다.
if (NULL != p)
	delete p;
해줄 필요가 없다. 알아서 NULL인 경우를 처리한다.

해제한 메모리를 또 해제해서는 안된다.
해제한 메모리는 이제 더 이상 소유가 아니다.
16_3.cpp
오류 발생

메모리를 해제한다고 해서 메모리의 주소를 보관하고 있던 포인터 변수까지 정리하는 것은 아니다.
이 포인터 변수를 다시 NULL값으로 초기화해줘야 한다.
아무것도 가리키지 않는 포인터에는 항상 NULL값이 들어 있어야 한다.
p가 가리키는 메모리를 해제한 후에는 반드시 p에 NULL 값을 넣어 주어야 한다.
16_4.cpp

할당한 메모리의 크기를 잊어버린 경우는 어떻게 하나요?
다시 알아낼 방법이 없다.
얼마만큼의 크기를 할당했는지도 어딘가에 보관해둘 필요가 있다.
사실 할당한 메모리 공간을 사용하기 위해서 두 가지 정보(메모리 주소와 크기)모두 필요하다.
주소를 가지고 있다고해서 메모리 공간을 사용하는 것은 불가능.
void ClearMemory(char* p, int size){
	for (int i = 0; i < size; ++i)
		p[i] = 0;
}
메모리의 주소와 크기, p와 size는 같이 다녀야 하는 경우가 많이 있다.

02 동적 메모리 할당의 응용
동적 메모리 할당으로만 할 수 있는 일
문자열의 내용을 뒤집는 문자열을 새로 만들어서 반환.
16_5.cpp
ReverseString()에서 새로운 문자열을 위한 메모리를 할당하고, 주소를 반환했다.
함수는 끝났지만 동적으로 할당된 메모리는 여전히 존재하고, 그 메모리를 사용할 수 있었다.
그리고 copy가 가리키는 메모리를 해제한 후에 NULL로 초기화해줬다.

정말 동적 메모리 할당으로만 할 수 있을까
동적메모리 할당이 아닌 배열을 사용했을 경우
16_6.cpp
이미 소멸된 공간에 접근해서 이상한 문자들이 찍혀있다.
ReverseFunction()함수가 종료되면서 reverse의 주소값을 반환하긴 하지만
reverse배열도 같이 소멸해서 다른 공간이 됨.

스택과 자유 저장소
C++는 메모리를 몇 가지 종류로 나누어서 생각한다.
물리적으로는 같은 메모리지만 나름대로 종류별로 나눠서 사용한다.
대표적인 곳이 스택(Stack)과 자유 저장소(Free Store).
스택은 함수 안에서 정의한 변수들이 위치하는 곳.
먼저 정의한 변수가 메모리의 아래쪽(높은 주소)에 위치하게 된다.
자유 저장소는 new, new[]를 통해 동적으로 할당한 메모리 공간들이 위치하는 곳.

*/